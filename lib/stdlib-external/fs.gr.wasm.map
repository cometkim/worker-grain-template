{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/bindings/wasi_snapshot_preview1.ts","stdlib-external/ascutils/errors.ts","stdlib-external/ascutils/tags.ts","stdlib-external/ascutils/primitives.ts","stdlib-external/sys/file.ts","stdlib-external/ascutils/dataStructures.ts","~lib/memory.ts","~lib/util/memory.ts"],"names":[],"mappings":"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","sourceRoot":"./fs.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/snapshot/witx\n\n/* tslint:disable:max-line-length */\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n@unmanaged abstract class $event { // size=16/32\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred. */\n@unmanaged export abstract class event extends $event {\n  private __padding1: u64;\n  private __padding2: u64;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends $event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/* Information about a pre-opened capability. */\n@unmanaged export abstract class prestat extends $prestat {\n  private __padding0: usize;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\n@unmanaged export class prestat_dir extends $prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n@unmanaged abstract class $subscription { // size=16/48\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription extends $subscription {\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n  private __padding4: u64;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends $subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends $subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n","export const GRAIN_ERR_NOT_NUMBER_COMP: u32 = 0\nexport const GRAIN_ERR_NOT_NUMBER_ARITH: u32 = 1\nexport const GRAIN_ERR_NOT_BOOLEAN_LOGIC: u32 = 2\nexport const GRAIN_ERR_NOT_BOOLEAN_IF: u32 = 3\nexport const GRAIN_ERR_OVERFLOW: u32 = 4\nexport const GRAIN_ERR_GET_NOT_TUP: u32 = 5\nexport const GRAIN_ERR_GET_ITEM_IDX_NOT_NUMBER: u32 = 6\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_SMALL: u32 = 7\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_LARGE: u32 = 8\nexport const GRAIN_ERR_CALLED_NON_FUNCTION: u32 = 9\nexport const GRAIN_ERR_ARITY_MISMATCH: u32 = 10\nexport const GRAIN_ERR_OUT_OF_MEMORY: u32 = 11\nexport const GRAIN_ERR_SET_NOT_TUP: u32 = 12\nexport const GRAIN_ERR_SET_ITEM_IDX_NOT_NUMBER: u32 = 13\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_SMALL: u32 = 14\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_LARGE: u32 = 15\nexport const GRAIN_ERR_DIVISION_BY_ZERO: u32 = 17\nexport const GRAIN_ERR_MODULO_BY_ZERO: u32 = 18\nexport const GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS: u32 = 19\nexport const GRAIN_ERR_INVALID_ARGUMENT: u32 = 20\nexport const GRAIN_ERR_ASSERTION_ERROR: u32 = 21\nexport const GRAIN_ERR_FAILURE: u32 = 22\nexport const GRAIN_ERR_SYSTEM: u32 = 23\nexport const GRAIN_ERR_NOT_INTLIKE: u32 = 24\nexport const GRAIN_ERR_NOT_RATIONAL: u32 = 25\nexport const GRAIN_ERR_MALFORMED_UTF8: u32 = 26\nexport const GRAIN_ERR_NOT_ADT_VAL_GENERIC: u32 = 91\nexport const GRAIN_ERR_NOT_STRING_GENERIC: u32 = 93\nexport const GRAIN_ERR_NOT_BOOLEAN_GENERIC: u32 = 94\nexport const GRAIN_ERR_NOT_TUPLE_GENERIC: u32 = 95\nexport const GRAIN_ERR_NOT_LAMBDA_GENERIC: u32 = 96\nexport const GRAIN_ERR_BAD_INPUT: u32 = 97\nexport const GRAIN_ERR_NOT_NONNEG: u32 = 98\nexport const GRAIN_ERR_NOT_NUMBER_GENERIC: u32 = 99\n","export const GRAIN_NUMBER_TAG_TYPE: i32       = 0b0000;\nexport const GRAIN_CONST_TAG_TYPE: i32        = 0b1111;\nexport const GRAIN_TUPLE_TAG_TYPE: i32        = 0b0001;\nexport const GRAIN_LAMBDA_TAG_TYPE: i32       = 0b0101;\nexport const GRAIN_GENERIC_HEAP_TAG_TYPE: i32 = 0b0011;\n\nexport const GRAIN_NUMBER_TAG_MASK: i32 = 0b0001;\nexport const GRAIN_GENERIC_TAG_MASK: i32 = 0b0111;\n\nexport const GRAIN_STRING_HEAP_TAG: i32 = 1;\nexport const GRAIN_CHAR_HEAP_TAG: i32 = 2;\nexport const GRAIN_ADT_HEAP_TAG: i32 = 3;\nexport const GRAIN_RECORD_HEAP_TAG: i32 = 4;\nexport const GRAIN_ARRAY_HEAP_TAG: i32 = 5;\nexport const GRAIN_BOXED_NUM_HEAP_TAG: i32 = 6;\n\nexport const GRAIN_FILE_DESCRIPTOR_TYPE_ID: i32 = 9;\n\n// Boxed number types\nexport const GRAIN_FLOAT32_BOXED_NUM_TAG = 1;\nexport const GRAIN_FLOAT64_BOXED_NUM_TAG = 2;\nexport const GRAIN_INT32_BOXED_NUM_TAG = 3;\nexport const GRAIN_INT64_BOXED_NUM_TAG = 4;\nexport const GRAIN_RATIONAL_BOXED_NUM_TAG = 5;\n","export const GRAIN_TRUE: u32 = 0xFFFFFFFF\nexport const GRAIN_FALSE: u32 = 0x7FFFFFFF\nexport const GRAIN_VOID: u32 = 0x6FFFFFFF\n","import { malloc, free, throwError } from \"../ascutils/grainRuntime\";\n\nimport {\n  errno,\n  lookupflags,\n  oflags,\n  rights,\n  fdflags,\n  fdstat,\n  filestat,\n  fstflags,\n  path_open,\n  fd_read,\n  fd_pread,\n  fd_write,\n  fd_pwrite,\n  fd_allocate,\n  fd_close,\n  fd_datasync,\n  fd_sync,\n  fd_fdstat_get,\n  fd_fdstat_set_flags,\n  fd_fdstat_set_rights,\n  fd_filestat_get,\n  fd_filestat_set_size,\n  fd_filestat_set_times,\n  fd_readdir,\n  fd_renumber,\n  fd_seek,\n  fd_tell,\n  path_create_directory,\n  path_filestat_get,\n  path_filestat_set_times,\n  path_link,\n  path_symlink,\n  path_unlink_file,\n  path_readlink,\n  path_remove_directory,\n  path_rename,\n} from \"bindings/wasi\";\n\nimport { GRAIN_ERR_SYSTEM } from \"../ascutils/errors\";\n\nimport { GRAIN_GENERIC_HEAP_TAG_TYPE, GRAIN_STRING_HEAP_TAG, GRAIN_TUPLE_TAG_TYPE, GRAIN_ARRAY_HEAP_TAG } from \"../ascutils/tags\";\n\nimport { GRAIN_VOID } from \"../ascutils/primitives\";\n\nimport { loadAdtVal, loadAdtVariant, stringSize, allocateString, allocateTuple, allocateInt64, allocateArray } from '../ascutils/dataStructures'\n\nnamespace glookupflag {\n  // @ts-ignore: decorator\n  @inline\n  export const SymlinkFollow: u32 = 0\n}\n\nnamespace goflag {\n  // @ts-ignore: decorator\n  @inline\n  export const Create: u32 = 0\n  // @ts-ignore: decorator\n  @inline\n  export const Directory: u32 = 2\n  // @ts-ignore: decorator\n  @inline\n  export const Exclusive: u32 = 4\n  // @ts-ignore: decorator\n  @inline\n  export const Truncate: u32 = 6\n}\n\nnamespace grights {\n  // @ts-ignore decorator\n  @inline\n  export const FdDatasync: u32 = 0\n  // @ts-ignore decorator\n  @inline\n  export const FdRead: u32 = 2\n  // @ts-ignore decorator\n  @inline\n  export const FdSeek: u32 = 4\n  // @ts-ignore decorator\n  @inline\n  export const FdSetFlags: u32 = 6\n  // @ts-ignore decorator\n  @inline\n  export const FdSync: u32 = 8\n  // @ts-ignore decorator\n  @inline\n  export const FdTell: u32 = 10\n  // @ts-ignore decorator\n  @inline\n  export const FdWrite: u32 = 12\n  // @ts-ignore decorator\n  @inline\n  export const FdAdvise: u32 = 14\n  // @ts-ignore decorator\n  @inline\n  export const FdAllocate: u32 = 16\n  // @ts-ignore decorator\n  @inline\n  export const PathCreateDirectory: u32 = 18\n  // @ts-ignore decorator\n  @inline\n  export const PathCreateFile: u32 = 20\n  // @ts-ignore decorator\n  @inline\n  export const PathLinkSource: u32 = 22\n  // @ts-ignore decorator\n  @inline\n  export const PathLinkTarget: u32 = 24\n  // @ts-ignore decorator\n  @inline\n  export const PathOpen: u32 = 26\n  // @ts-ignore decorator\n  @inline\n  export const FdReaddir: u32 = 28\n  // @ts-ignore decorator\n  @inline\n  export const PathReadlink: u32 = 30\n  // @ts-ignore decorator\n  @inline\n  export const PathRenameSource: u32 = 32\n  // @ts-ignore decorator\n  @inline\n  export const PathRenameTarget: u32 = 34\n  // @ts-ignore decorator\n  @inline\n  export const PathFilestats: u32 = 36\n  // @ts-ignore decorator\n  @inline\n  export const PathSetSize: u32 = 38\n  // @ts-ignore decorator\n  @inline\n  export const PathSetTimes: u32 = 40\n  // @ts-ignore decorator\n  @inline\n  export const FdFilestats: u32 = 42\n  // @ts-ignore decorator\n  @inline\n  export const FdSetSize: u32 = 44\n  // @ts-ignore decorator\n  @inline\n  export const FdSetTimes: u32 = 46\n  // @ts-ignore decorator\n  @inline\n  export const PathSymlink: u32 = 48\n  // @ts-ignore decorator\n  @inline\n  export const PathRemoveDirectory: u32 = 50\n  // @ts-ignore decorator\n  @inline\n  export const PathUnlinkFile: u32 = 52\n  // @ts-ignore decorator\n  @inline\n  export const PollFdReadwrite: u32 = 54\n  // @ts-ignore decorator\n  @inline\n  export const SockShutdown: u32 = 56\n}\n\nnamespace gfdflag {\n  // @ts-ignore decorator\n  @inline\n  export const Append: u32 = 0\n  // @ts-ignore decorator\n  @inline\n  export const Dsync: u32 = 2\n  // @ts-ignore decorator\n  @inline\n  export const Nonblock: u32 = 4\n  // @ts-ignore decorator\n  @inline\n  export const Rsync: u32 = 6\n  // @ts-ignore decorator\n  @inline\n  export const Sync: u32 = 8\n}\n\nfunction combineLookupflags(dirflags: u32): u32 {\n  let combinedDirFlags: u32 = 0\n  let listPtr = dirflags ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  while (loadAdtVariant(listPtr) !== 0) {\n    let adt = loadAdtVal(listPtr, 0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (loadAdtVariant(adt)) {\n      case glookupflag.SymlinkFollow: {\n        combinedDirFlags = combinedDirFlags | lookupflags.SYMLINK_FOLLOW\n        break\n      }\n    }\n    listPtr = loadAdtVal(listPtr, 1) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n  return combinedDirFlags\n}\n\nfunction combineOFlags(openflags: u32): u16 {\n  let combinedOFlags: u16 = 0\n  let listPtr = openflags ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  while (loadAdtVariant(listPtr) !== 0) {\n    let adt = loadAdtVal(listPtr, 0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (loadAdtVariant(adt)) {\n      case goflag.Create: {\n        combinedOFlags = combinedOFlags | oflags.CREAT\n        break\n      }\n      case goflag.Directory: {\n        combinedOFlags = combinedOFlags | oflags.DIRECTORY\n        break\n      }\n      case goflag.Exclusive: {\n        combinedOFlags = combinedOFlags | oflags.EXCL\n        break\n      }\n      case goflag.Truncate: {\n        combinedOFlags = combinedOFlags | oflags.TRUNC\n        break\n      }\n    }\n    listPtr = loadAdtVal(listPtr, 1) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n  return combinedOFlags\n}\n\nfunction combineRights(grightsl: u32): u64 {\n  let combinedRights: u64 = 0\n  let listPtr = grightsl ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  while (loadAdtVariant(listPtr) !== 0) {\n    let adt = loadAdtVal(listPtr, 0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (loadAdtVariant(adt)) {\n      case grights.FdDatasync: {\n        combinedRights = combinedRights | rights.FD_DATASYNC\n        break\n      }\n      case grights.FdRead: {\n        combinedRights = combinedRights | rights.FD_READ\n        break\n      }\n      case grights.FdSeek: {\n        combinedRights = combinedRights | rights.FD_SEEK\n        break\n      }\n      case grights.FdSetFlags: {\n        combinedRights = combinedRights | rights.FD_FDSTAT_SET_FLAGS\n        break\n      }\n      case grights.FdSync: {\n        combinedRights = combinedRights | rights.FD_SYNC\n        break\n      }\n      case grights.FdTell: {\n        combinedRights = combinedRights | rights.FD_TELL\n        break\n      }\n      case grights.FdWrite: {\n        combinedRights = combinedRights | rights.FD_WRITE\n        break\n      }\n      case grights.FdAdvise: {\n        combinedRights = combinedRights | rights.FD_ADVISE\n        break\n      }\n      case grights.FdAllocate: {\n        combinedRights = combinedRights | rights.FD_ALLOCATE\n        break\n      }\n      case grights.PathCreateDirectory: {\n        combinedRights = combinedRights | rights.PATH_CREATE_DIRECTORY\n        break\n      }\n      case grights.PathCreateFile: {\n        combinedRights = combinedRights | rights.PATH_CREATE_FILE\n        break\n      }\n      case grights.PathLinkSource: {\n        combinedRights = combinedRights | rights.PATH_LINK_SOURCE\n        break\n      }\n      case grights.PathLinkTarget: {\n        combinedRights = combinedRights | rights.PATH_LINK_TARGET\n        break\n      }\n      case grights.PathOpen: {\n        combinedRights = combinedRights | rights.PATH_OPEN\n        break\n      }\n      case grights.FdReaddir: {\n        combinedRights = combinedRights | rights.FD_READDIR\n        break\n      }\n      case grights.PathReadlink: {\n        combinedRights = combinedRights | rights.PATH_READLINK\n        break\n      }\n      case grights.PathRenameSource: {\n        combinedRights = combinedRights | rights.PATH_RENAME_SOURCE\n        break\n      }\n      case grights.PathRenameTarget: {\n        combinedRights = combinedRights | rights.PATH_RENAME_TARGET\n        break\n      }\n      case grights.PathFilestats: {\n        combinedRights = combinedRights | rights.PATH_FILESTAT_GET\n        break\n      }\n      case grights.PathSetSize: {\n        combinedRights = combinedRights | rights.PATH_FILESTAT_SET_SIZE\n        break\n      }\n      case grights.PathSetTimes: {\n        combinedRights = combinedRights | rights.PATH_FILESTAT_SET_TIMES\n        break\n      }\n      case grights.FdFilestats: {\n        combinedRights = combinedRights | rights.FD_FILESTAT_GET\n        break\n      }\n      case grights.FdSetSize: {\n        combinedRights = combinedRights | rights.FD_FILESTAT_SET_SIZE\n        break\n      }\n      case grights.FdSetTimes: {\n        combinedRights = combinedRights | rights.FD_FILESTAT_SET_TIMES\n        break\n      }\n      case grights.PathSymlink: {\n        combinedRights = combinedRights | rights.RIGHT_PATH_SYMLINK\n        break\n      }\n      case grights.PathRemoveDirectory: {\n        combinedRights = combinedRights | rights.PATH_REMOVE_DIRECTORY\n        break\n      }\n      case grights.PathUnlinkFile: {\n        combinedRights = combinedRights | rights.PATH_UNLINK_FILE\n        break\n      }\n      case grights.PollFdReadwrite: {\n        combinedRights = combinedRights | rights.POLL_FD_READWRITE\n        break\n      }\n      case grights.SockShutdown: {\n        combinedRights = combinedRights | rights.SOCK_SHUTDOWN\n        break\n      }\n    }\n    listPtr = loadAdtVal(listPtr, 1) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n\n  return combinedRights\n}\n\nfunction combineFdFlags(flagsl: u32): u16 {\n  let combinedFdFlags: u16 = 0\n  let listPtr = flagsl ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  while (loadAdtVariant(listPtr) !== 0) {\n    let adt = loadAdtVal(listPtr, 0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (loadAdtVariant(adt)) {\n      case gfdflag.Append: {\n        combinedFdFlags = combinedFdFlags | fdflags.APPEND\n        break\n      }\n      case gfdflag.Dsync: {\n        combinedFdFlags = combinedFdFlags | fdflags.DSYNC\n        break\n      }\n      case gfdflag.Nonblock: {\n        combinedFdFlags = combinedFdFlags | fdflags.NONBLOCK\n        break\n      }\n      case gfdflag.Rsync: {\n        combinedFdFlags = combinedFdFlags | fdflags.RSYNC\n        break\n      }\n      case gfdflag.Sync: {\n        combinedFdFlags = combinedFdFlags | fdflags.SYNC\n        break\n      }\n    }\n    listPtr = loadAdtVal(listPtr, 1) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n\n  return combinedFdFlags\n}\n\nexport function pathOpen(\n  dirfd: u32,\n  dirflags: u32,\n  path: u32,\n  openflags: u32,\n  fsRightsBase: u32,\n  fsRightsInheriting: u32,\n  fsFlags: u32\n): u32 {\n  dirfd = dirfd ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let dirfdval = loadAdtVal(dirfd, 0) >> 1\n  \n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  path = path ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathLength = stringSize(path)\n  path += 8 // Offset the string pointer to the start of the string\n\n  let combinedOFlags = combineOFlags(openflags)\n\n  let rightsBase = combineRights(fsRightsBase)\n  let rightsInheriting = combineRights(fsRightsInheriting)\n  \n  let combinedFsFlags = combineFdFlags(fsFlags)\n\n  let newFd = malloc(6 * 4)\n  memory.copy(newFd, dirfd, 6 * 4)\n\n  let fdPtr = newFd + (5 * 4)\n  \n  let err = path_open(\n    dirfdval,\n    combinedDirFlags,\n    path,\n    pathLength,\n    combinedOFlags,\n    rightsBase,\n    rightsInheriting,\n    combinedFsFlags,\n    fdPtr\n  )\n  if (err !== errno.SUCCESS) {\n    free(newFd)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  // Tag fd\n  store<u32>(newFd, load<u32>(newFd, 5 * 4) << 1, 5 * 4)\n  \n  return newFd ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function fdRead(fdPtr: u32, n: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  n = n >> 1\n\n  let iovs = malloc(3 * 4)\n  let strPtr = allocateString(n)\n\n  store<u32>(iovs, strPtr + (2 * 4))\n  store<u32>(iovs, n, 4)\n\n  let nread = iovs + (3 * 4)\n\n  let err = fd_read(fd, iovs, 1, nread)\n  if (err !== errno.SUCCESS) {\n    free(iovs)\n    free(strPtr)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  nread = load<u32>(nread)\n  \n  let tuple = allocateTuple(2)\n\n  store<u32>(tuple, strPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n  store<u32>(tuple, nread << 1, 2 * 4)\n  store<u32>(strPtr, nread, 4)\n\n  free(iovs)\n\n  return tuple ^ GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function fdPread(fdPtr: u32, offsetPtr: u32, n: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  offsetPtr = offsetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let offset = load<u64>(offsetPtr, 4)\n\n  n = n >> 1\n\n  let iovs = malloc(3 * 4)\n  let strPtr = allocateString(n)\n\n  store<u32>(iovs, strPtr + (2 * 4))\n  store<u32>(iovs, n, 4)\n\n  let nread = iovs + (3 * 4)\n\n  let err = fd_pread(fd, iovs, 1, offset, nread)\n  if (err !== errno.SUCCESS) {\n    free(iovs)\n    free(strPtr)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  nread = load<u32>(nread)\n  \n  let tuple = allocateTuple(2)\n\n  store<u32>(tuple, strPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n  store<u32>(tuple, nread << 1, 2 * 4)\n  store<u32>(strPtr, nread, 4)\n\n  free(iovs)\n\n  return tuple ^ GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function fdWrite(fdPtr: u32, data: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let iovs = malloc(3 * 4)\n  let strPtr = data ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  store<u32>(iovs, strPtr + (2 * 4))\n  store<u32>(iovs, load<u32>(strPtr, 4), 4)\n\n  let nwritten = iovs + (3 * 4)\n\n  let err = fd_write(fd, iovs, 1, nwritten)\n  if (err !== errno.SUCCESS) {\n    free(iovs)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  nwritten = load<u32>(nwritten)\n  \n  free(iovs)\n\n  return nwritten << 1\n}\n\nexport function fdPwrite(fdPtr: u32, data: u32, offsetPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n  \n  let iovs = malloc(3 * 4)\n  let strPtr = data ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  \n  store<u32>(iovs, strPtr + (2 * 4))\n  store<u32>(iovs, load<u32>(strPtr, 4), 4)\n\n  offsetPtr = offsetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let offset = load<u64>(offsetPtr, 4)\n\n  let nwritten = iovs + (3 * 4)\n\n  let err = fd_pwrite(fd, iovs, 1, offset, nwritten)\n  if (err !== errno.SUCCESS) {\n    free(iovs)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  nwritten = load<u32>(nwritten)\n  \n  free(iovs)\n\n  return nwritten << 1\n}\n\nexport function fdAllocate(fdPtr: u32, offsetPtr: u32, sizePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  offsetPtr = offsetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let offset = load<u64>(offsetPtr, 4)\n\n  sizePtr = sizePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let size = load<u64>(sizePtr, 4)\n  \n  let err = fd_allocate(fd, offset, size)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdClose(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let err = fd_close(fd)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdDatasync(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let err = fd_datasync(fd)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSync(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let err = fd_sync(fd)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdStats(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let structPtr = malloc(24)\n  \n  let err = fd_fdstat_get(fd, changetype<fdstat>(structPtr))\n  if (err !== errno.SUCCESS) {\n    free(structPtr)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  let filetype = load<u8>(structPtr)\n  let fdflags = load<u16>(structPtr, 4)\n  let rights = load<u64>(structPtr, 8)\n  let rightsInheriting = load<u64>(structPtr, 16)\n\n  let fdflagsPtr = allocateInt64()\n  store<u64>(fdflagsPtr, fdflags, 4)\n\n  let rightsPtr = allocateInt64()\n  store<u64>(rightsPtr, rights, 4)\n\n  let rightsInheritingPtr = allocateInt64()\n  store<u64>(rightsInheritingPtr, rightsInheriting, 4)\n\n  let tuple = allocateTuple(4)\n  store<u32>(tuple, filetype << 1, 4)\n  store<u32>(tuple, fdflagsPtr | GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n  store<u32>(tuple, rightsPtr | GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n  store<u32>(tuple, rightsInheritingPtr | GRAIN_GENERIC_HEAP_TAG_TYPE, 4 * 4)\n\n  free(structPtr)\n\n  return tuple | GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function fdSetFlags(fdPtr: u32, flagsPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let flags: u16 = 0\n  let listPtr = flagsPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  while (loadAdtVariant(listPtr) !== 0) {\n    let adt = loadAdtVal(listPtr, 0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (loadAdtVariant(adt)) {\n      case gfdflag.Append: {\n        flags = flags | fdflags.APPEND\n        break\n      }\n      case gfdflag.Dsync: {\n        flags = flags | fdflags.DSYNC\n        break\n      }\n      case gfdflag.Nonblock: {\n        flags = flags | fdflags.NONBLOCK\n        break\n      }\n      case gfdflag.Rsync: {\n        flags = flags | fdflags.RSYNC\n        break\n      }\n      case gfdflag.Sync: {\n        flags = flags | fdflags.SYNC\n        break\n      }\n    }\n    listPtr = loadAdtVal(listPtr, 1) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n  \n  let err = fd_fdstat_set_flags(fd, flags)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSetRights(fdPtr: u32, rightsPtr: u32, rightsInheritingPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let rights = combineRights(rightsPtr)\n  let rightsInheriting = combineRights(rightsInheritingPtr)\n  \n  let err = fd_fdstat_set_rights(fd, rights, rightsInheriting)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdFilestats(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let stats = malloc(64)\n\n  let filestats = changetype<filestat>(stats)\n  \n  let err = fd_filestat_get(fd, filestats)\n  if (err !== errno.SUCCESS) {\n    free(stats)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  let tuple = allocateTuple(8)\n\n  let dev = allocateInt64()\n  store<u64>(dev, filestats.dev, 4)\n  let ino = allocateInt64()\n  store<u64>(ino, filestats.ino, 4)\n  let nlink = allocateInt64()\n  store<u64>(nlink, filestats.nlink, 4)\n  let size = allocateInt64()\n  store<u64>(size, filestats.size, 4)\n  let atim = allocateInt64()\n  store<u64>(atim, filestats.atim, 4)\n  let mtim = allocateInt64()\n  store<u64>(mtim, filestats.mtim, 4)\n  let ctim = allocateInt64()\n  store<u64>(ctim, filestats.ctim, 4)\n\n  store<u32>(tuple, dev ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n  store<u32>(tuple, ino ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n  store<u32>(tuple, filestats.filetype << 1, 3 * 4)\n  store<u32>(tuple, nlink ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4 * 4)\n  store<u32>(tuple, size ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 5 * 4)\n  store<u32>(tuple, atim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 6 * 4)\n  store<u32>(tuple, mtim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 7 * 4)\n  store<u32>(tuple, ctim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 8 * 4)\n\n  free(stats)\n\n  return tuple ^ GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function fdSetSize(fdPtr: u32, sizePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  sizePtr = sizePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let size = load<u64>(sizePtr, 4)\n\n  let err = fd_filestat_set_size(fd, size)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSetAccessTime(fdPtr: u32, timePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  timePtr = timePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let time = load<u64>(timePtr, 4)\n\n  let err = fd_filestat_set_times(fd, time, 0, fstflags.SET_ATIM)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSetAccessTimeNow(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let err = fd_filestat_set_times(fd, 0, 0, fstflags.SET_ATIM_NOW)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSetModifiedTime(fdPtr: u32, timePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  timePtr = timePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let time = load<u64>(timePtr, 4)\n\n  let err = fd_filestat_set_times(fd, 0, time, fstflags.SET_MTIM)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSetModifiedTimeNow(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let err = fd_filestat_set_times(fd, 0, 0, fstflags.SET_MTIM_NOW)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdReaddir(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  const structWidth = 24\n\n  let bufUsed = malloc(4)\n  let cookie: u64 = 0\n  \n  let buf = malloc(structWidth)\n  let bufLen = structWidth\n  \n  let err = fd_readdir(fd, buf, bufLen, cookie, bufUsed)\n  if (err !== errno.SUCCESS) {\n    free(buf)\n    free(bufUsed)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  let used = load<u32>(bufUsed)\n  \n  if (used <= 0) {\n    free(buf)\n    free(bufUsed)\n    return allocateArray(0) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n\n  bufLen = load<u32>(buf, 16) + structWidth * 2\n\n  free(buf)\n  \n   // simple linked list\n  // ptr +0 -> current buffer\n  // ptr +4 -> bufs\n  let bufs = 0\n\n  let numEntries = 0\n\n  while (true) {\n    numEntries++\n    \n    buf = malloc(bufLen)\n    let cons = malloc(8)\n    store<u32>(cons, buf)\n    store<u32>(cons, bufs, 4)\n    bufs = cons\n\n    let err = fd_readdir(fd, buf, bufLen, cookie, bufUsed)\n    if (err !== errno.SUCCESS) {\n      while (bufs !== 0) {\n        free(load<u32>(bufs))\n        let next = load<u32>(bufs, 4)\n        free(bufs)\n        bufs = next\n      }\n      free(bufUsed)\n      throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n    }\n\n    if (load<u32>(bufUsed) !== bufLen) {\n      break\n    } else {\n      let curLen = load<u32>(buf, 16)\n      cookie = load<u64>(buf)\n      let nextDirentPtr = buf + structWidth + curLen\n      bufLen = load<u32>(nextDirentPtr, 16) + structWidth * 2\n    }\n  }\n\n  free(bufUsed)\n\n  let arr = allocateArray(numEntries)\n\n  for (let i = numEntries - 1; i >= 0; i--) {\n    let dirent = load<u32>(bufs)\n    let tuple = allocateTuple(3)\n\n    let inode = allocateInt64()\n    store<u64>(inode, load<u64>(dirent, 8), 4)\n\n    let dirnameLen = load<u32>(dirent, 16)\n    let dirname = allocateString(dirnameLen)\n    memory.copy(dirname + 8, dirent + structWidth, dirnameLen)\n\n    let filetype = load<u8>(dirent, 20) << 1\n    \n    store<u32>(tuple, inode ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n    store<u32>(tuple, dirname ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n    store<u32>(tuple, filetype, 3 * 4)\n\n    store<u32>(arr + i * 4, tuple ^ GRAIN_TUPLE_TAG_TYPE, 8)\n\n    let next = load<u32>(bufs, 4)\n    free(bufs)\n    free(dirent)\n\n    bufs = next\n  }\n  \n  return arr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function fdRenumber(fromFdPtr: u32, toFdPtr: u32): u32 {\n  fromFdPtr = fromFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fromFd = loadAdtVal(fromFdPtr, 0) >> 1\n\n  toFdPtr = toFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let toFd = loadAdtVal(toFdPtr, 0) >> 1\n\n  let err = fd_renumber(fromFd, toFd)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function fdSeek(fdPtr: u32, offsetPtr: u32, whencePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  offsetPtr = offsetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let offset = load<u64>(offsetPtr, 4)\n\n  whencePtr = whencePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let whence = u8(load<u32>(whencePtr, 12) >> 1)\n\n  let newoffset = allocateInt64()\n  let newoffsetPtr = newoffset + 4\n  \n  let err = fd_seek(fd, offset, whence, newoffsetPtr)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return newoffset ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function fdTell(fdPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let offset = allocateInt64()\n  let offsetPtr = offset + 4\n  \n  let err = fd_tell(fd, offsetPtr)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return offset ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function pathCreateDirectory(fdPtr: u32, stringPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  stringPtr = stringPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  \n  let size = load<u32>(stringPtr, 4)\n\n  stringPtr += 8\n  \n  let err = path_create_directory(fd, stringPtr, size)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathFilestats(fdPtr: u32, dirflags: u32, pathPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n  \n  let stats = malloc(64)\n\n  let filestats = changetype<filestat>(stats)\n  \n  let err = path_filestat_get(fd, combinedDirFlags, pathPtr, pathSize, filestats)\n  if (err !== errno.SUCCESS) {\n    free(stats)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  let tuple = allocateTuple(8)\n\n  let dev = allocateInt64()\n  store<u64>(dev, filestats.dev, 4)\n  let ino = allocateInt64()\n  store<u64>(ino, filestats.ino, 4)\n  let nlink = allocateInt64()\n  store<u64>(nlink, filestats.nlink, 4)\n  let size = allocateInt64()\n  store<u64>(size, filestats.size, 4)\n  let atim = allocateInt64()\n  store<u64>(atim, filestats.atim, 4)\n  let mtim = allocateInt64()\n  store<u64>(mtim, filestats.mtim, 4)\n  let ctim = allocateInt64()\n  store<u64>(ctim, filestats.ctim, 4)\n\n  store<u32>(tuple, dev ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n  store<u32>(tuple, ino ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n  store<u32>(tuple, filestats.filetype << 1, 3 * 4)\n  store<u32>(tuple, nlink ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4 * 4)\n  store<u32>(tuple, size ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 5 * 4)\n  store<u32>(tuple, atim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 6 * 4)\n  store<u32>(tuple, mtim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 7 * 4)\n  store<u32>(tuple, ctim ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 8 * 4)\n\n  free(stats)\n\n  return tuple ^ GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function pathSetAccessTime(fdPtr: u32, dirflags: u32, pathPtr: u32, timePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  timePtr = timePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let time = load<u64>(timePtr, 4)\n\n  let err = path_filestat_set_times(fd, combinedDirFlags, pathPtr, pathSize, time, 0, fstflags.SET_ATIM)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathSetAccessTimeNow(fdPtr: u32, dirflags: u32, pathPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  let err = path_filestat_set_times(fd, combinedDirFlags, pathPtr, pathSize, 0, 0, fstflags.SET_ATIM_NOW)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathSetModifiedTime(fdPtr: u32, dirflags: u32, pathPtr: u32, timePtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  timePtr = timePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let time = load<u64>(timePtr, 4)\n\n  let err = path_filestat_set_times(fd, combinedDirFlags, pathPtr, pathSize, 0, time, fstflags.SET_MTIM)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathSetModifiedTimeNow(fdPtr: u32, dirflags: u32, pathPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  let err = path_filestat_set_times(fd, combinedDirFlags, pathPtr, pathSize, 0, 0, fstflags.SET_MTIM_NOW)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathLink(sourceFdPtr: u32, dirflags: u32, sourcePtr: u32, targetFdPtr: u32, targetPtr: u32): u32 {\n  sourceFdPtr = sourceFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let sourceFd = loadAdtVal(sourceFdPtr, 0) >> 1\n\n  targetFdPtr = targetFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let targetFd = loadAdtVal(targetFdPtr, 0) >> 1\n\n  let combinedDirFlags = combineLookupflags(dirflags)\n\n  sourcePtr = sourcePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let sourceSize = load<u32>(sourcePtr, 4)\n  sourcePtr += 8\n\n  targetPtr = targetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let targetSize = load<u32>(targetPtr, 4)\n  targetPtr += 8\n\n  let err = path_link(sourceFd, combinedDirFlags, sourcePtr, sourceSize, targetFd, targetPtr, targetSize)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathSymlink(fdPtr: u32, sourcePtr: u32, targetPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  sourcePtr = sourcePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let sourceSize = load<u32>(sourcePtr, 4)\n  sourcePtr += 8\n\n  targetPtr = targetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let targetSize = load<u32>(targetPtr, 4)\n  targetPtr += 8\n\n  let err = path_symlink(sourcePtr, sourceSize, fd, targetPtr, targetSize)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathUnlink(fdPtr: u32, pathPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  let err = path_unlink_file(fd, pathPtr, pathSize)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathReadlink(fdPtr: u32, pathPtr: u32, size: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  size = size >> 1\n\n  let grainStrPtr = allocateString(size)\n  let strPtr = grainStrPtr + 8\n\n  let nread = malloc(4)\n\n  let err = path_readlink(fd, pathPtr, pathSize, strPtr, size, nread)\n  if (err !== errno.SUCCESS) {\n    free(grainStrPtr)\n    free(nread)\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  let tuple = allocateTuple(2)\n\n  store<u32>(tuple, grainStrPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE, 4)\n  store<u32>(tuple, load<u32>(nread) << 1, 2 * 4)\n\n  free(nread)\n\n  return tuple ^ GRAIN_TUPLE_TAG_TYPE\n}\n\nexport function pathRemoveDirectory(fdPtr: u32, pathPtr: u32): u32 {\n  fdPtr = fdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let fd = loadAdtVal(fdPtr, 0) >> 1\n\n  pathPtr = pathPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let pathSize = load<u32>(pathPtr, 4)\n  pathPtr += 8\n\n  let err = path_remove_directory(fd, pathPtr, pathSize)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n\nexport function pathRename(sourceFdPtr: u32, sourcePtr: u32, targetFdPtr: u32, targetPtr: u32): u32 {\n  sourceFdPtr = sourceFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let sourceFd = loadAdtVal(sourceFdPtr, 0) >> 1\n\n  targetFdPtr = targetFdPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let targetFd = loadAdtVal(targetFdPtr, 0) >> 1\n\n  sourcePtr = sourcePtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let sourceSize = load<u32>(sourcePtr, 4)\n  sourcePtr += 8\n\n  targetPtr = targetPtr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let targetSize = load<u32>(targetPtr, 4)\n  targetPtr += 8\n\n  let err = path_rename(sourceFd, sourcePtr, sourceSize, targetFd, targetPtr, targetSize)\n  if (err !== errno.SUCCESS) {\n    throwError(GRAIN_ERR_SYSTEM, err << 1, 0)\n  }\n\n  return GRAIN_VOID\n}\n","import { malloc } from './grainRuntime'\n\nimport {\n  GRAIN_ARRAY_HEAP_TAG,\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n} from './tags'\n\n/**\n * Allocates a new Grain array.\n *\n * @param {u32} numElts The number of elements to be contained in this array\n * @returns {u32} The (untagged) pointer to the array\n */\nexport function allocateArray(numElts: u32): u32 {\n  let arr = malloc((numElts + 2) * 4)\n\n  store<u32>(arr, GRAIN_ARRAY_HEAP_TAG)\n  store<u32>(arr, numElts, 4)\n\n  return arr\n}\n\n/**\n * Stores an item in a Grain array.\n *\n * @param {u32} array The (untagged) array to store the item in\n * @param {u32} idx The index to store the item\n * @param {u32} item The item to store\n */\n@inline\nexport function storeInArray(arr: u32, idx: u32, item: u32): void {\n  store<u32>(arr + idx * 4, item, 8)\n}\n\n/**\n * Allocates a new Grain tuple.\n *\n * @param {u32} numElts The number of elements to be contained in this tuple\n * @returns {u32} The (untagged) pointer to the tuple\n */\nexport function allocateTuple(numElts: u32): u32 {\n  let tuple = malloc((numElts + 1) * 4)\n\n  store<u32>(tuple, numElts)\n\n  return tuple\n}\n\n/**\n * Allocates a new Grain string.\n *\n * @param {u32} size The size (in bytes) of the string to allocate\n * @returns {u32} The (untagged) pointer to the string\n */\nexport function allocateString(size: u32): u32 {\n  let str = malloc(size + 8)\n\n  store<u32>(str, GRAIN_STRING_HEAP_TAG)\n  store<u32>(str, size, 4)\n\n  return str\n}\n\n/**\n * Allocates a new Grain char.\n *\n * @returns {u32} The (untagged) pointer to the char\n */\nexport function allocateChar(): u32 {\n  let char = malloc(8)\n\n  store<u32>(char, GRAIN_CHAR_HEAP_TAG)\n\n  return char\n}\n\nexport function singleByteString(char: u8): u32 {\n  let s = allocateString(1)\n  store<u8>(s, char, 8)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function twoByteString(char1: u8, char2: u8): u32 {\n  let s = allocateString(2)\n  store<u8>(s, char1, 8)\n  store<u8>(s, char2, 8 + 1)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// [TODO] should probably migrate over the accessors in numbers.ts\n// INT32/INT64\n\n/**\n * Allocates a new Int64.\n *\n * @returns {u32}\n */\nexport function allocateInt64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int64 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt64(value: i64): u32 {\n  let ptr = allocateInt64()\n  store<i64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int64\n * @param wrappedInt64 The boxed int64 to return\n */\nexport function rawInt64Ptr(wrappedInt64: u32): u32 {\n  return wrappedInt64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64Unsigned(xptr: u32): u64 {\n  return load<u64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Int32.\n *\n * @returns {u32}\n */\nexport function allocateInt32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int32 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt32(value: i32): u32 {\n  let ptr = allocateInt32()\n  store<i32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int32\n * @param wrappedInt32 The boxed int32 to return\n */\nexport function rawInt32Ptr(wrappedInt32: u32): u32 {\n  return wrappedInt32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32Unsigned(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// FLOATS\n\n/**\n * Allocates a new Float32.\n *\n * @returns {u32}\n */\nexport function allocateFloat32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float32 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat32(value: f32): u32 {\n  let ptr = allocateFloat32()\n  store<f32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float32\n * @param wrappedFloat32 The boxed float32 to return\n */\nexport function rawFloat32Ptr(wrappedFloat32: u32): u32 {\n  return wrappedFloat32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat32(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Float64.\n *\n * @returns {u32}\n */\nexport function allocateFloat64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float64 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat64(value: f64): u32 {\n  let ptr = allocateFloat64()\n  store<f64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float64\n * @param wrappedFloat64 The boxed float64 to return\n */\nexport function rawFloat64Ptr(wrappedFloat64: u32): u32 {\n  return wrappedFloat64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat64(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// RATIONALS\n\n/**\n * Allocates a new Rational.\n *\n * @returns {u32}\n */\nexport function allocateRational(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_RATIONAL_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Rational with a prepopulated value\n * @param value The value to store\n */\nexport function newRational(numerator: i32, denominator: i32): u32 {\n  let ptr = allocateRational()\n  store<i32>(ptr + 8, numerator)\n  store<i32>(ptr + 12, denominator)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalNumeratorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 8\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalDenominatorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 12\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n/**\n * Load a value from an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @param {u32} idx Index (from zero) of the item\n * @returns {u32} The value located at the index\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVal(ptr: u32, idx: u32): u32 {\n  return load<u32>(ptr + (idx * 4), 5 * 4)\n}\n\n/**\n * Load the (tagged) variant of an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @returns {u32} The (tagged) ADT variant id\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVariant(ptr: u32): u32 {\n  return load<u32>(ptr, 3 * 4)\n}\n\n/**\n * Load an untagged string's size.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the string\n * @returns {u32} The (untagged) string size (in bytes)\n */\n// @ts-ignore: decorator\n@inline\nexport function stringSize(ptr: u32): u32 {\n  return load<u32>(ptr, 4)\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n - 4;\n    store<u8>(dest, c);\n    store<u8>(dend, c, 3);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend, c, 2);\n    store<u8>(dend, c, 1);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n - 28;\n    store<u32>(dest, c32);\n    store<u32>(dend, c32, 24);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend, c32, 16);\n    store<u32>(dend, c32, 20);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend, c32);\n    store<u32>(dend, c32, 4);\n    store<u32>(dend, c32, 8);\n    store<u32>(dend, c32, 12);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n"]}