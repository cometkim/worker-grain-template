{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","stdlib-external/ascutils/tags.ts","stdlib-external/ascutils/primitives.ts","stdlib-external/ascutils/errors.ts","stdlib-external/int64.ts","stdlib-external/ascutils/dataStructures.ts"],"names":[],"mappings":"qlBM0GG,AAAU,AAAO,MAEjB,AAAW,EAAK,KAChB,AAAW,EAAM,GAAG,KAEpB,OAQA,AAAU,IACV,AAAW,EAAM,GAAG,KACpB,AAAO,EAAM,UD/Gb,AAAe,EAAU,IC6HzB,AAAiB,EAAO,AAAC,UD7HK,KAC9B,AAAgB,WAIhB,AAAe,EAAU,ICwHzB,AAAiB,EAAO,AAAC,UDxHK,KAC9B,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,ICmHxC,AAAiB,EAAO,AAAC,aDlHzB,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,IC8GxC,AAAiB,EAAO,AAAC,aD7GzB,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,ICyGxC,AAAiB,EAAO,AAAC,aDxGzB,AAAgB,WAIhB,AAAa,EAAU,kBACvB,AAAI,EAAQ,KACV,AAAW,EAA4B,EAAG,MAE5C,AAAe,EAAU,ICgGzB,AAAiB,EAAO,AAAC,UDhGK,KAC9B,AAAgB,WAIhB,AAAa,EAAkB,kBAC/B,AAAI,EAAQ,KACV,AAAW,EAA4B,EAAG,MAE5C,AAAe,EAAkB,IC6FjC,AAAiB,EAAO,AAAC,UD7Fa,KACtC,AAAgB,WAIhB,AAAa,EAAU,kBACvB,AAAI,EAAQ,KACV,AAAW,EAA4B,EAAG,MAE5C,AAAe,EAAU,IC8EzB,AAAiB,EAAO,AAAC,UD9EK,KAC9B,AAAgB,WAIhB,AAAa,EAAkB,kBAC/B,AAAI,EAAQ,KACV,AAAW,EAA4B,EAAG,MAE5C,AAAe,EAAkB,IC2EjC,AAAiB,EAAO,AAAC,UD3Ea,KACtC,AAAgB,OC8DhB,AAAO,EAAe,WD1DtB,AAAa,AAAY,MACzB,AAAa,AAAY,MAEzB,AAAI,EAAQ,KACV,AAAW,EAA0B,EAAG,MAK1C,AAAI,AAAC,GAAO,YAAa,GAAO,eAE9B,AAAO,AAAS,EAAO,SAGvB,AAAe,AAAS,gBAAQ,AAAS,mBACzC,AAAO,AAAS,EAAU,KAAI,AAAC,AAAS,gBAAQ,GAAW,EAAO,KAAI,GAAK,KAAK,eAKlF,AAAe,EAAU,gBAAK,EAAU,IC4CxC,AAAiB,EAAO,AAAC,aD3CzB,AAAO,IAAS,GAAa,QAI7B,AAAe,EAAU,gBAAK,EAAU,ICuCxC,AAAiB,EAAO,AAAC,aDtCzB,AAAO,IAAS,GAAa,QAI7B,AAAe,EAAU,gBAAM,EAAU,ICkCzC,AAAiB,EAAO,AAAC,aDjCzB,AAAO,IAAS,GAAa,QAI7B,AAAe,EAAU,gBAAM,EAAU,IC6BzC,AAAiB,EAAO,AAAC,aD5BzB,AAAO,IAAS,GAAa,UAI7B,AAAe,AAAC,EAAU,ICwB1B,AAAiB,EAAO,AAAC,eDvBzB,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,ICmBxC,AAAiB,EAAO,AAAC,aDlBzB,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,ICcxC,AAAiB,EAAO,AAAC,aDbzB,AAAgB,WAIhB,AAAe,EAAU,gBAAK,EAAU,ICSxC,AAAiB,EAAO,AAAC,aDRzB,AAAgB,WAIhB,AAAe,EAAU,gBAAM,EAAU,ICIzC,AAAiB,EAAO,AAAC,aDHzB,AAAgB,WAIhB,AAAe,EAAU,gBAAM,EAAU,ICDzC,AAAiB,EAAO,AAAC,aDEzB,AAAgB,WAIhB,AAAe,EAAU,gBAAO,EAAU,ICN1C,AAAiB,EAAO,AAAC,aDOzB,AAAgB","sourceRoot":"./int64.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","export const GRAIN_NUMBER_TAG_TYPE: i32       = 0b0000;\nexport const GRAIN_CONST_TAG_TYPE: i32        = 0b1111;\nexport const GRAIN_TUPLE_TAG_TYPE: i32        = 0b0001;\nexport const GRAIN_LAMBDA_TAG_TYPE: i32       = 0b0101;\nexport const GRAIN_GENERIC_HEAP_TAG_TYPE: i32 = 0b0011;\n\nexport const GRAIN_NUMBER_TAG_MASK: i32 = 0b0001;\nexport const GRAIN_GENERIC_TAG_MASK: i32 = 0b0111;\n\nexport const GRAIN_STRING_HEAP_TAG: i32 = 1;\nexport const GRAIN_CHAR_HEAP_TAG: i32 = 2;\nexport const GRAIN_ADT_HEAP_TAG: i32 = 3;\nexport const GRAIN_RECORD_HEAP_TAG: i32 = 4;\nexport const GRAIN_ARRAY_HEAP_TAG: i32 = 5;\nexport const GRAIN_BOXED_NUM_HEAP_TAG: i32 = 6;\n\nexport const GRAIN_FILE_DESCRIPTOR_TYPE_ID: i32 = 9;\n\n// Boxed number types\nexport const GRAIN_FLOAT32_BOXED_NUM_TAG = 1;\nexport const GRAIN_FLOAT64_BOXED_NUM_TAG = 2;\nexport const GRAIN_INT32_BOXED_NUM_TAG = 3;\nexport const GRAIN_INT64_BOXED_NUM_TAG = 4;\nexport const GRAIN_RATIONAL_BOXED_NUM_TAG = 5;\n","export const GRAIN_TRUE: u32 = 0xFFFFFFFF\nexport const GRAIN_FALSE: u32 = 0x7FFFFFFF\nexport const GRAIN_VOID: u32 = 0x6FFFFFFF\n","export const GRAIN_ERR_NOT_NUMBER_COMP: u32 = 0\nexport const GRAIN_ERR_NOT_NUMBER_ARITH: u32 = 1\nexport const GRAIN_ERR_NOT_BOOLEAN_LOGIC: u32 = 2\nexport const GRAIN_ERR_NOT_BOOLEAN_IF: u32 = 3\nexport const GRAIN_ERR_OVERFLOW: u32 = 4\nexport const GRAIN_ERR_GET_NOT_TUP: u32 = 5\nexport const GRAIN_ERR_GET_ITEM_IDX_NOT_NUMBER: u32 = 6\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_SMALL: u32 = 7\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_LARGE: u32 = 8\nexport const GRAIN_ERR_CALLED_NON_FUNCTION: u32 = 9\nexport const GRAIN_ERR_ARITY_MISMATCH: u32 = 10\nexport const GRAIN_ERR_OUT_OF_MEMORY: u32 = 11\nexport const GRAIN_ERR_SET_NOT_TUP: u32 = 12\nexport const GRAIN_ERR_SET_ITEM_IDX_NOT_NUMBER: u32 = 13\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_SMALL: u32 = 14\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_LARGE: u32 = 15\nexport const GRAIN_ERR_DIVISION_BY_ZERO: u32 = 17\nexport const GRAIN_ERR_MODULO_BY_ZERO: u32 = 18\nexport const GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS: u32 = 19\nexport const GRAIN_ERR_INVALID_ARGUMENT: u32 = 20\nexport const GRAIN_ERR_ASSERTION_ERROR: u32 = 21\nexport const GRAIN_ERR_FAILURE: u32 = 22\nexport const GRAIN_ERR_SYSTEM: u32 = 23\nexport const GRAIN_ERR_NOT_INTLIKE: u32 = 24\nexport const GRAIN_ERR_NOT_RATIONAL: u32 = 25\nexport const GRAIN_ERR_MALFORMED_UTF8: u32 = 26\nexport const GRAIN_ERR_NOT_ADT_VAL_GENERIC: u32 = 91\nexport const GRAIN_ERR_NOT_STRING_GENERIC: u32 = 93\nexport const GRAIN_ERR_NOT_BOOLEAN_GENERIC: u32 = 94\nexport const GRAIN_ERR_NOT_TUPLE_GENERIC: u32 = 95\nexport const GRAIN_ERR_NOT_LAMBDA_GENERIC: u32 = 96\nexport const GRAIN_ERR_BAD_INPUT: u32 = 97\nexport const GRAIN_ERR_NOT_NONNEG: u32 = 98\nexport const GRAIN_ERR_NOT_NUMBER_GENERIC: u32 = 99\n","import { GRAIN_GENERIC_HEAP_TAG_TYPE } from './ascutils/tags'\nimport { newInt64, rawInt64Ptr, loadInt64, loadInt64Unsigned } from \"./ascutils/dataStructures\";\nimport { GRAIN_FALSE, GRAIN_TRUE } from \"./ascutils/primitives\";\nimport {\n  GRAIN_ERR_DIVISION_BY_ZERO,\n  GRAIN_ERR_MODULO_BY_ZERO,\n} from './ascutils/errors'\nimport { throwError } from './ascutils/grainRuntime'\n\nexport function incr(x: u32): u32 {\n  const result = loadInt64(x) + 1\n  return newInt64(result)\n}\n\nexport function decr(x: u32): u32 {\n  const result = loadInt64(x) - 1\n  return newInt64(result)\n}\n\nexport function add(x: u32, y: u32): u32 {\n  const result = loadInt64(x) + loadInt64(y)\n  return newInt64(result)\n}\n\nexport function sub(x: u32, y: u32): u32 {\n  const result = loadInt64(x) - loadInt64(y)\n  return newInt64(result)\n}\n\nexport function mul(x: u32, y: u32): u32 {\n  const result = loadInt64(x) * loadInt64(y)\n  return newInt64(result)\n}\n\nexport function div(x: u32, y: u32): u32 {\n  const yval = loadInt64(y)\n  if (yval == 0) {\n    throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n  }\n  const result = loadInt64(x) / yval\n  return newInt64(result)\n}\n\nexport function divU(x: u32, y: u32): u32 {\n  const yval = loadInt64Unsigned(y)\n  if (yval == 0) {\n    throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n  }\n  const result = loadInt64Unsigned(x) / yval\n  return newInt64(result)\n}\n\nexport function rem(x: u32, y: u32): u32 {\n  const yval = loadInt64(y)\n  if (yval == 0) {\n    throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n  }\n  const result = loadInt64(x) % yval\n  return newInt64(result)\n}\n\nexport function remU(x: u32, y: u32): u32 {\n  const yval = loadInt64Unsigned(y)\n  if (yval == 0) {\n    throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n  }\n  const result = loadInt64Unsigned(x) % yval\n  return newInt64(result)\n}\n\nexport function mod(x: u32, y: u32): u32 {\n  const xval = rawInt64Ptr(x)\n  const yval = rawInt64Ptr(y)\n\n  if (yval == 0) {\n    throwError(GRAIN_ERR_MODULO_BY_ZERO, 0, 0)\n  }\n\n  const bitmask : u64 = 0x8000000000000000\n  // AssemblyScript's % is the remainder operator, so we implement modulo manually\n  if ((xval & bitmask) == (yval & bitmask)) {\n    // Signs match\n    return newInt64(xval % yval)\n  } else {\n    // Signs are different\n    const modval = abs<i64>(xval) % abs<i64>(yval)\n    return newInt64(modval != 0 ? (abs<i64>(yval) - modval) * (yval < 0 ? -1 : 1) : modval)\n  }\n}\n\nexport function lt(x: u32, y: u32): u32 {\n  const result = loadInt64(x) < loadInt64(y)\n  return result ? GRAIN_TRUE : GRAIN_FALSE\n}\n\nexport function gt(x: u32, y: u32): u32 {\n  const result = loadInt64(x) > loadInt64(y)\n  return result ? GRAIN_TRUE : GRAIN_FALSE\n}\n\nexport function lte(x: u32, y: u32): u32 {\n  const result = loadInt64(x) <= loadInt64(y)\n  return result ? GRAIN_TRUE : GRAIN_FALSE\n}\n\nexport function gte(x: u32, y: u32): u32 {\n  const result = loadInt64(x) >= loadInt64(y)\n  return result ? GRAIN_TRUE : GRAIN_FALSE\n}\n\nexport function lnot(x: u32): u32 {\n  const result = ~loadInt64(x)\n  return newInt64(result)\n}\n\nexport function land(x: u32, y: u32): u32 {\n  const result = loadInt64(x) & loadInt64(y)\n  return newInt64(result)\n}\n\nexport function lor(x: u32, y: u32): u32 {\n  const result = loadInt64(x) | loadInt64(y)\n  return newInt64(result)\n}\n\nexport function lxor(x: u32, y: u32): u32 {\n  const result = loadInt64(x) ^ loadInt64(y)\n  return newInt64(result)\n}\n\nexport function shl(x: u32, y: u32): u32 {\n  const result = loadInt64(x) << loadInt64(y)\n  return newInt64(result)\n}\n\nexport function shr(x: u32, y: u32): u32 {\n  const result = loadInt64(x) >> loadInt64(y)\n  return newInt64(result)\n}\n\nexport function shrU(x: u32, y: u32): u32 {\n  const result = loadInt64(x) >>> loadInt64(y)\n  return newInt64(result)\n}\n\n","import { malloc } from './grainRuntime'\n\nimport {\n  GRAIN_ARRAY_HEAP_TAG,\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n} from './tags'\n\n/**\n * Allocates a new Grain array.\n *\n * @param {u32} numElts The number of elements to be contained in this array\n * @returns {u32} The (untagged) pointer to the array\n */\nexport function allocateArray(numElts: u32): u32 {\n  let arr = malloc((numElts + 2) * 4)\n\n  store<u32>(arr, GRAIN_ARRAY_HEAP_TAG)\n  store<u32>(arr, numElts, 4)\n\n  return arr\n}\n\n/**\n * Stores an item in a Grain array.\n *\n * @param {u32} array The (untagged) array to store the item in\n * @param {u32} idx The index to store the item\n * @param {u32} item The item to store\n */\n@inline\nexport function storeInArray(arr: u32, idx: u32, item: u32): void {\n  store<u32>(arr + idx * 4, item, 8)\n}\n\n/**\n * Allocates a new Grain tuple.\n *\n * @param {u32} numElts The number of elements to be contained in this tuple\n * @returns {u32} The (untagged) pointer to the tuple\n */\nexport function allocateTuple(numElts: u32): u32 {\n  let tuple = malloc((numElts + 1) * 4)\n\n  store<u32>(tuple, numElts)\n\n  return tuple\n}\n\n/**\n * Allocates a new Grain string.\n *\n * @param {u32} size The size (in bytes) of the string to allocate\n * @returns {u32} The (untagged) pointer to the string\n */\nexport function allocateString(size: u32): u32 {\n  let str = malloc(size + 8)\n\n  store<u32>(str, GRAIN_STRING_HEAP_TAG)\n  store<u32>(str, size, 4)\n\n  return str\n}\n\n/**\n * Allocates a new Grain char.\n *\n * @returns {u32} The (untagged) pointer to the char\n */\nexport function allocateChar(): u32 {\n  let char = malloc(8)\n\n  store<u32>(char, GRAIN_CHAR_HEAP_TAG)\n\n  return char\n}\n\nexport function singleByteString(char: u8): u32 {\n  let s = allocateString(1)\n  store<u8>(s, char, 8)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function twoByteString(char1: u8, char2: u8): u32 {\n  let s = allocateString(2)\n  store<u8>(s, char1, 8)\n  store<u8>(s, char2, 8 + 1)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// [TODO] should probably migrate over the accessors in numbers.ts\n// INT32/INT64\n\n/**\n * Allocates a new Int64.\n *\n * @returns {u32}\n */\nexport function allocateInt64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int64 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt64(value: i64): u32 {\n  let ptr = allocateInt64()\n  store<i64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int64\n * @param wrappedInt64 The boxed int64 to return\n */\nexport function rawInt64Ptr(wrappedInt64: u32): u32 {\n  return wrappedInt64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64Unsigned(xptr: u32): u64 {\n  return load<u64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Int32.\n *\n * @returns {u32}\n */\nexport function allocateInt32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int32 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt32(value: i32): u32 {\n  let ptr = allocateInt32()\n  store<i32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int32\n * @param wrappedInt32 The boxed int32 to return\n */\nexport function rawInt32Ptr(wrappedInt32: u32): u32 {\n  return wrappedInt32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32Unsigned(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// FLOATS\n\n/**\n * Allocates a new Float32.\n *\n * @returns {u32}\n */\nexport function allocateFloat32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float32 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat32(value: f32): u32 {\n  let ptr = allocateFloat32()\n  store<f32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float32\n * @param wrappedFloat32 The boxed float32 to return\n */\nexport function rawFloat32Ptr(wrappedFloat32: u32): u32 {\n  return wrappedFloat32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat32(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Float64.\n *\n * @returns {u32}\n */\nexport function allocateFloat64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float64 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat64(value: f64): u32 {\n  let ptr = allocateFloat64()\n  store<f64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float64\n * @param wrappedFloat64 The boxed float64 to return\n */\nexport function rawFloat64Ptr(wrappedFloat64: u32): u32 {\n  return wrappedFloat64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat64(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// RATIONALS\n\n/**\n * Allocates a new Rational.\n *\n * @returns {u32}\n */\nexport function allocateRational(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_RATIONAL_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Rational with a prepopulated value\n * @param value The value to store\n */\nexport function newRational(numerator: i32, denominator: i32): u32 {\n  let ptr = allocateRational()\n  store<i32>(ptr + 8, numerator)\n  store<i32>(ptr + 12, denominator)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalNumeratorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 8\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalDenominatorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 12\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n/**\n * Load a value from an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @param {u32} idx Index (from zero) of the item\n * @returns {u32} The value located at the index\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVal(ptr: u32, idx: u32): u32 {\n  return load<u32>(ptr + (idx * 4), 5 * 4)\n}\n\n/**\n * Load the (tagged) variant of an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @returns {u32} The (tagged) ADT variant id\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVariant(ptr: u32): u32 {\n  return load<u32>(ptr, 3 * 4)\n}\n\n/**\n * Load an untagged string's size.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the string\n * @returns {u32} The (untagged) string size (in bytes)\n */\n// @ts-ignore: decorator\n@inline\nexport function stringSize(ptr: u32): u32 {\n  return load<u32>(ptr, 4)\n}\n"]}