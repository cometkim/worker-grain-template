{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","stdlib-external/runtime/malloc.ts"],"names":[],"mappings":"oUE4DG,AAAS,IACT,AAAmB,IACnB,AAAqB,IACrB,AAAoB,IACpB,AAAW,IAEX,AAAI,EAAY,KACd,AAAW,IACX,AAAI,EAAS,KAGX,AAAU,EAAS,KACnB,AAAU,EAAW,KACrB,AAAU,EAAU,KACpB,AAAY,AAAY,MACxB,AAAI,EAAa,KACf,AAAO,KAET,EAAY,EAAW,OAEzB,AAAO,KAGP,AAAU,IACV,AAAU,EAAW,KACrB,AAAU,EAAU,KACpB,AAAY,AAAY,MACxB,AAAI,EAAa,KACf,AAAO,KAET,EAAY,EAAW,OAEzB,QA4HA,AAAQ,KAER,AAAoB,EAAK,KACzB,AAAa,IAIb,AAAI,EAAY,KACd,GAKA,AAAI,QACJ,AAAE,AAAC,EAAW,KAAO,EAAW,EAAQ,wBAGxC,AAAI,AAAC,EAAK,EAAQ,aAAQ,AAAC,EAAW,QAAO,EAAW,EAAQ,kBAC9D,KAHF,AAAI,EAAQ,iBAQd,AAAI,EAAW,EAAQ,WAAa,EAAQ,aAC1C,AAAW,EAAQ,YACnB,EAAQ,IAAU,EAAQ,UAAY,EAAQ,qBAC9C,EAAQ,IAAU,EAAQ,qBAElB,IAAU,EAAQ,oBAG5B,AAAI,EAAI,EAAQ,WAAM,KACpB,EAAQ,IAAG,EAAQ,UAAK,EAAQ,IA7IlC,AAAiB,SAKjB,AAAW,EAAK,MAyId,EAAQ,IAAG,EAAQ,IAxJrB,AAAiB,iBA0JP,IAAG,IArJb,AAAW,EAAK,MAwJhB,AAAU,SAnEV,AAAc,IACd,AAAc,IAEd,AAAe,IAEf,AAAK,AAAS,MAEd,AAAI,EAAM,KACR,AAAO,KAIT,AAAkB,EAAW,KAC7B,AAAK,IACL,EAAQ,IAAI,YAGZ,AAAK,EAAK,GAAI,KAEd,QAnFA,AAAkB,EAAK,KACvB,AAAa,IACb,AAAiB,IACjB,AAAkB,IAIlB,AAAS,AAAC,EAAS,GAAmB,GAAK,GAAmB,KAC9D,AAAS,EAAU,KAEnB,AAAQ,IAER,AAAI,EAAY,KACd,AAAW,EAAG,KACd,AAAU,IACV,AAAQ,IACR,AAAW,EAAG,MAGX,AAAI,EAAQ,0BACf,AAAW,EAAQ,YACnB,AAAI,EAAQ,KAEV,AAAI,EAAQ,KAEF,IAAO,EAAQ,oBAGvB,AAAc,EAAO,KACrB,EAAQ,IAAG,YACX,AAAI,EAAI,KACR,EAAQ,IAAG,aAGb,AAAU,IAIV,AAAO,AAAU,EAAI,GAAG,OAG1B,AAAI,EAAK,KAEP,AAAI,AAAS,MAEb,AAAI,EAAK,KAEP,AAAO,OA5Bc,EAAQ,IAAG,AAAI,EAAQ,IA7ClD,AAAiB,cA8EjB,KAyFA","sourceRoot":"./malloc.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","@external(\"memoryManager\", \"_malloc\")\nexport declare function extMalloc(rawPtr: u32, bytes: u32): u32\n@external(\"memoryManager\", \"_free\")\nexport declare function extFree(ptr: u32): u32\n@external(\"memoryManager\", \"_growHeap\")\nexport declare function extGrowHeap(numPages: u32): u32\n@external(\"memoryManager\", \"_initialHeapSize\")\nexport declare const initialHeapSize: u32\n\n/* UNDERSTANDING THE STRUCTURE OF THE FREE LIST\n * The original K&R definition for the free list entry type was the following:\n *\n *     union header {\n *         struct {\n *             union header *ptr;\n *             unsigned size;\n *         } s;\n *         long x; // <- forces 8-byte alignment\n *     };\n *\n * In memory, this is really just two ints (assuming we're working in 32-bit mode).\n * As such, we manually lay out the entries in the heap as follows (note that we\n * use helpers to facilitate accessing and setting these values):\n *\n *            AS                   C Equivalent\n *   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n *   let ptr      ===  union header *ptr\n *   getNext(ptr) ===  ptr->s.ptr\n *   getSize(ptr) ===  ptr->s.size\n */\n\n/**\n * Pointer to the start of the free list. This is always a multiple of\n * 8, with the exception of its initial value (used as a sentinel).\n */\nlet freePtr: u32 = 1;\n\n/**\n * Size (in bytes) of entries in the free list.\n */\nlet mallocHeaderSize: u32 = 8;\n\n/**\n * log_2(mallocHeaderSize) (multiplication by the header\n * size is equivalent to left-shifting by this amount)\n */\nlet logMallocHeaderSize: u32 = 3;\n\n/**\n * The current size (in bytes) of the heap.\n */\nlet heapSize: u32 = 0;\n\n/**\n * Requests that the heap be grown by the given number of bytes.\n *\n * @param {u32} nbytes - The number of bytes requested\n * @return {u32} - If unsuccessful, -1. Otherwise, the pointer to the beginning of the extended region.\n */\nexport function growHeap(nbytes: u32): u32 {\n  nbytes = nbytes;\n  let reqSize: u32 = 0;\n  let reqResult: u32 = 0;\n  let origSize: u32 = 0;\n  origSize = heapSize;\n  // If the size has not been initialized, do so.\n  if (heapSize == 0) {\n    heapSize = initialHeapSize;\n    if (nbytes > heapSize) {\n      // More bytes requested than the initial heap size,\n      // so we need to request more anyway.\n      reqSize = nbytes - heapSize;\n      reqSize = reqSize >> 16;\n      reqSize = reqSize + 1;\n      reqResult = extGrowHeap(reqSize);\n      if (reqResult == -1) {\n        return -1;\n      }\n      heapSize += reqSize << 16;\n    }\n    return 0;\n  } else {\n    // The size has already been initialized, so call the external function.\n    reqSize = nbytes;\n    reqSize = reqSize >> 16;\n    reqSize = reqSize + 1;\n    reqResult = extGrowHeap(reqSize);\n    if (reqResult == -1) {\n      return -1;\n    }\n    heapSize += reqSize << 16;\n  }\n  return reqResult;\n}\n\n@inline\nfunction getNext(ptr: u32): u32 {\n  return load<u32>(ptr)\n}\n\n@inline\nfunction setNext(ptr: u32, val: u32): void {\n  store<u32>(ptr, val)\n}\n\n@inline\nfunction getSize(ptr: u32): u32 {\n  return load<u32>(ptr, 4)\n}\n\n@inline\nfunction setSize(ptr: u32, val: u32): void {\n  store<u32>(ptr, val, 4)\n}\n\n/**\n * Allocates the requested number of bytes, returning a pointer.\n *\n * @param nbytes {u32} - The number of bytes to allocate\n * @return {u32} - The pointer to the allocated region (8-byte aligned), or -1 if the allocation failed.\n */\nexport function malloc(nb: u32): u32 {\n  // Add space for GC header\n  let nbytes: u32 = nb + 8;\n  let p: u32 = 0;\n  let prevp: u32 = 0;\n  let nunits: u32 = 0;\n\n  // Set nbytes to the next multiple of mallocHeaderSize greater\n  // than the given size\n  nunits = (nbytes + mallocHeaderSize - 1) / mallocHeaderSize + 1;\n  nbytes = nunits << logMallocHeaderSize; // multiply by header size\n\n  prevp = freePtr;\n  // Handle initialization\n  if (heapSize == 0) {\n    store<u32>(0, 0)\n    freePtr = 0;\n    prevp = 0;\n    store<u32>(4, 0)\n  }\n  // Search the freelist for any blocks large enough.\n  for (p = getNext(prevp); ; prevp = p, p = getNext(p)) {\n    let size = getSize(p);\n    if (size >= nbytes) {\n      // If this block is big enough, allocate from it.\n      if (size == nbytes) {\n        // It's exactly the right size!\n        setNext(prevp, getNext(p));\n      } else {\n        // Shrink it as needed\n        let newSize = size - nbytes;\n        setSize(p, newSize)\n        p = p + newSize;\n        setSize(p, nbytes)\n      }\n      // Update the pointer to the free list.\n      freePtr = prevp;\n\n      // Let runtime set up reference counting\n      // Address of the region past the malloc header\n      return extMalloc(p + 8, nb);\n    }\n    // We've reached the end of the free list. Time to grow the heap.\n    if (p == freePtr) {\n      // Attempt to grow the heap\n      p = morecore(nbytes);\n      // If growing the heap failed, return -1.\n      if (p == -1) {\n        // Error\n        return -1;\n      }\n    }\n  }\n  // Error\n  return -1;\n}\n\n/**\n * Asks the runtime for more heap memory.\n * (if you can't tell from the fact that the name is reminiscient\n *  of the 1970s, the name of this function is taken from K&R).\n *\n * @param nbytes {u32} - The number of bytes to try to grow the heap by\n * @return {u32} - If successful, a pointer to the start of the free list. If not successful, -1.\n */\nexport function morecore(nbytes: u32): u32 {\n  let cp: u32 = 0;\n  let up: u32 = 0;\n\n  let origSize = heapSize;\n\n  cp = growHeap(nbytes);\n  // If there was an error, return\n  if (cp == -1) {\n    return -1;\n  }\n  // Set the size of the new block to the amount the\n  // heap was grown.\n  let grownAmount = heapSize - origSize;\n  up = cp;\n  setSize(up, grownAmount);\n  // Call free() with the new block to add it to the free list.\n  // Add an additional 8 for the expected GC header\n  free(up + 8 + 8);\n  // Return the free list pointer.\n  return freePtr;\n}\n\n/**\n * Frees the given allocated pointer.\n *\n * @param ap {u32} - The pointer to free\n */\nexport function free(ap: u32): void {\n  // Let memory manager know we're freeing this pointer\n  extFree(ap);\n\n  let blockPtr: u32 = ap - 16; // 8 bytes for malloc header + 8 bytes for GC header\n  let p: u32 = 0;\n\n  // Edge case: for the first free (called by morecore), the free pointer\n  // is actually already pointing to this node, so we don't do anything.\n  if (blockPtr == freePtr) {\n    return;\n  }\n\n  // Find the location to insert this block into the free list\n  for (\n    p = freePtr;\n    !((blockPtr > p) && (blockPtr < getNext(p)));\n    p = getNext(p)\n  ) {\n    if ((p >= getNext(p)) && ((blockPtr > p) || (blockPtr < getNext(p)))) {\n      break;\n    }\n  }\n\n  // Merge the block into the adjacent free list entry above, if needed\n  if (blockPtr + getSize(blockPtr) == getNext(p)) {\n    let next = getNext(p);\n    setSize(blockPtr, getSize(blockPtr) + getSize(next))\n    setNext(blockPtr, getNext(next))\n  } else {\n    setNext(blockPtr, getNext(p))\n  }\n  // Merge the previous (adjacent) free list entry into this block, if needed\n  if (p + getSize(p) == blockPtr) {\n    setSize(p, getSize(p) + getSize(blockPtr))\n    setNext(p, getNext(blockPtr))\n  } else {\n    setNext(p, blockPtr)\n  }\n  // Set the free list head to this block\n  freePtr = p;\n}\n\n/**\n * Returns the current free list pointer\n * (used for debugging)\n *\n * @return {u32} - The free list pointer\n */\nexport function getFreePtr(): u32 {\n  return freePtr;\n}\n"]}