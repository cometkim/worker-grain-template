{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/bindings/wasi_snapshot_preview1.ts","stdlib-external/ascutils/tags.ts","stdlib-external/ascutils/primitives.ts","stdlib-external/ascutils/charCodes.ts","stdlib-external/ascutils/numberUtils.ts","stdlib-external/ascutils/errors.ts","stdlib-external/equal.ts","stdlib-external/runtime/string.ts","stdlib-external/runtime/print.ts","stdlib-external/ascutils/dataStructures.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/string.ts","~lib/memory.ts","~lib/util/memory.ts","stdlib-external/numbers.ts","~lib/number.ts","~lib/builtins.ts","stdlib-external/ascutils/console.ts","stdlib-external/ascutils/grainRuntime.ts"],"names":[],"mappings":"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,GAAO,OACpC,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QAExB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QACxB,AAAW,EAAa,QAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SACxB,AAAW,EAAa,SAExB,AAAW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","sourceRoot":"./print.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/master/phases/snapshot/witx\n\n/* tslint:disable:max-line-length */\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n@unmanaged abstract class $event { // size=16/32\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred. */\n@unmanaged export abstract class event extends $event {\n  private __padding1: u64;\n  private __padding2: u64;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends $event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/* Information about a pre-opened capability. */\n@unmanaged export abstract class prestat extends $prestat {\n  private __padding0: usize;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\n@unmanaged export class prestat_dir extends $prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n@unmanaged abstract class $subscription { // size=16/48\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription extends $subscription {\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n  private __padding4: u64;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends $subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends $subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n","export const GRAIN_NUMBER_TAG_TYPE: i32       = 0b0000;\nexport const GRAIN_CONST_TAG_TYPE: i32        = 0b1111;\nexport const GRAIN_TUPLE_TAG_TYPE: i32        = 0b0001;\nexport const GRAIN_LAMBDA_TAG_TYPE: i32       = 0b0101;\nexport const GRAIN_GENERIC_HEAP_TAG_TYPE: i32 = 0b0011;\n\nexport const GRAIN_NUMBER_TAG_MASK: i32 = 0b0001;\nexport const GRAIN_GENERIC_TAG_MASK: i32 = 0b0111;\n\nexport const GRAIN_STRING_HEAP_TAG: i32 = 1;\nexport const GRAIN_CHAR_HEAP_TAG: i32 = 2;\nexport const GRAIN_ADT_HEAP_TAG: i32 = 3;\nexport const GRAIN_RECORD_HEAP_TAG: i32 = 4;\nexport const GRAIN_ARRAY_HEAP_TAG: i32 = 5;\nexport const GRAIN_BOXED_NUM_HEAP_TAG: i32 = 6;\n\nexport const GRAIN_FILE_DESCRIPTOR_TYPE_ID: i32 = 9;\n\n// Boxed number types\nexport const GRAIN_FLOAT32_BOXED_NUM_TAG = 1;\nexport const GRAIN_FLOAT64_BOXED_NUM_TAG = 2;\nexport const GRAIN_INT32_BOXED_NUM_TAG = 3;\nexport const GRAIN_INT64_BOXED_NUM_TAG = 4;\nexport const GRAIN_RATIONAL_BOXED_NUM_TAG = 5;\n","export const GRAIN_TRUE: u32 = 0xFFFFFFFF\nexport const GRAIN_FALSE: u32 = 0x7FFFFFFF\nexport const GRAIN_VOID: u32 = 0x6FFFFFFF\n","export namespace CharCode {\n  // @ts-ignore: decorator\n  @inline\n  const NEWLINE: u8 = 0xA\n  // @ts-ignore: decorator\n  @inline\n  const SPACE: u8 = 0x20\n  // @ts-ignore: decorator\n  @inline\n  const QUOTE: u8 = 0x22\n  // @ts-ignore: decorator\n  @inline\n  const LPAREN: u8 = 0x28\n  // @ts-ignore: decorator\n  @inline\n  const RPAREN: u8 = 0x29\n  // @ts-ignore: decorator\n  @inline\n  const STAR: u8 = 0x2A\n  // @ts-ignore: decorator\n  @inline\n  const PLUS: u8 = 0x2B\n  // @ts-ignore: decorator\n  @inline\n  const COMMA: u8 = 0x2C\n  // @ts-ignore: decorator\n  @inline\n  const MINUS: u8 = 0x2D\n  // @ts-ignore: decorator\n  @inline\n  const DOT: u8 = 0x2E\n  // @ts-ignore: decorator\n  @inline\n  const SLASH: u8 = 0x2F\n  // @ts-ignore: decorator\n  @inline\n  const _0: u8 = 0x30\n  // @ts-ignore: decorator\n  @inline\n  const _1: u8 = 0x31\n  // @ts-ignore: decorator\n  @inline\n  const _2: u8 = 0x32\n  // @ts-ignore: decorator\n  @inline\n  const _3: u8 = 0x33\n  // @ts-ignore: decorator\n  @inline\n  const _4: u8 = 0x34\n  // @ts-ignore: decorator\n  @inline\n  const _5: u8 = 0x35\n  // @ts-ignore: decorator\n  @inline\n  const _6: u8 = 0x36\n  // @ts-ignore: decorator\n  @inline\n  const _7: u8 = 0x37\n  // @ts-ignore: decorator\n  @inline\n  const _8: u8 = 0x38\n  // @ts-ignore: decorator\n  @inline\n  const _9: u8 = 0x39\n  // @ts-ignore: decorator\n  @inline\n  const COLON: u8 = 0x3A\n  // @ts-ignore: decorator\n  @inline\n  const SEMICOLON: u8 = 0x3B\n  // @ts-ignore: decorator\n  @inline\n  const LANGLE: u8 = 0x3C // \"<\"\n  // @ts-ignore: decorator\n  @inline\n  const RANGLE: u8 = 0x3E // \">\"\n  // @ts-ignore: decorator\n  @inline\n  const A: u8 = 0x41\n  // @ts-ignore: decorator\n  @inline\n  const B: u8 = 0x42\n  // @ts-ignore: decorator\n  @inline\n  const C: u8 = 0x43\n  // @ts-ignore: decorator\n  @inline\n  const D: u8 = 0x44\n  // @ts-ignore: decorator\n  @inline\n  const E: u8 = 0x45\n  // @ts-ignore: decorator\n  @inline\n  const F: u8 = 0x46\n  // @ts-ignore: decorator\n  @inline\n  const G: u8 = 0x47\n  // @ts-ignore: decorator\n  @inline\n  const H: u8 = 0x48\n  // @ts-ignore: decorator\n  @inline\n  const I: u8 = 0x49\n  // @ts-ignore: decorator\n  @inline\n  const J: u8 = 0x4A\n  // @ts-ignore: decorator\n  @inline\n  const K: u8 = 0x4B\n  // @ts-ignore: decorator\n  @inline\n  const L: u8 = 0x4C\n  // @ts-ignore: decorator\n  @inline\n  const M: u8 = 0x4D\n  // @ts-ignore: decorator\n  @inline\n  const N: u8 = 0x4E\n  // @ts-ignore: decorator\n  @inline\n  const O: u8 = 0x4F\n  // @ts-ignore: decorator\n  @inline\n  const P: u8 = 0x50\n  // @ts-ignore: decorator\n  @inline\n  const Q: u8 = 0x51\n  // @ts-ignore: decorator\n  @inline\n  const R: u8 = 0x52\n  // @ts-ignore: decorator\n  @inline\n  const S: u8 = 0x53\n  // @ts-ignore: decorator\n  @inline\n  const T: u8 = 0x54\n  // @ts-ignore: decorator\n  @inline\n  const U: u8 = 0x55\n  // @ts-ignore: decorator\n  @inline\n  const V: u8 = 0x56\n  // @ts-ignore: decorator\n  @inline\n  const W: u8 = 0x57\n  // @ts-ignore: decorator\n  @inline\n  const X: u8 = 0x58\n  // @ts-ignore: decorator\n  @inline\n  const Z: u8 = 0x5A\n  // @ts-ignore: decorator\n  @inline\n  const LBRACK: u8 = 0x5B // \"[\"\n  // @ts-ignore: decorator\n  @inline\n  const RBRACK: u8 = 0x5D // \"]\"\n  // @ts-ignore: decorator\n  @inline\n  const a: u8 = 0x61\n  // @ts-ignore: decorator\n  @inline\n  const b: u8 = 0x62\n  // @ts-ignore: decorator\n  @inline\n  const c: u8 = 0x63\n  // @ts-ignore: decorator\n  @inline\n  const d: u8 = 0x64\n  // @ts-ignore: decorator\n  @inline\n  const e: u8 = 0x65\n  // @ts-ignore: decorator\n  @inline\n  const f: u8 = 0x66\n  // @ts-ignore: decorator\n  @inline\n  const g: u8 = 0x67\n  // @ts-ignore: decorator\n  @inline\n  const h: u8 = 0x68\n  // @ts-ignore: decorator\n  @inline\n  const i: u8 = 0x69\n  // @ts-ignore: decorator\n  @inline\n  const j: u8 = 0x6A\n  // @ts-ignore: decorator\n  @inline\n  const k: u8 = 0x6B\n  // @ts-ignore: decorator\n  @inline\n  const l: u8 = 0x6C\n  // @ts-ignore: decorator\n  @inline\n  const m: u8 = 0x6D\n  // @ts-ignore: decorator\n  @inline\n  const n: u8 = 0x6E\n  // @ts-ignore: decorator\n  @inline\n  const o: u8 = 0x6F\n  // @ts-ignore: decorator\n  @inline\n  const p: u8 = 0x70\n  // @ts-ignore: decorator\n  @inline\n  const q: u8 = 0x71\n  // @ts-ignore: decorator\n  @inline\n  const r: u8 = 0x72\n  // @ts-ignore: decorator\n  @inline\n  const s: u8 = 0x73\n  // @ts-ignore: decorator\n  @inline\n  const t: u8 = 0x74\n  // @ts-ignore: decorator\n  @inline\n  const u: u8 = 0x75\n  // @ts-ignore: decorator\n  @inline\n  const v: u8 = 0x76\n  // @ts-ignore: decorator\n  @inline\n  const w: u8 = 0x77\n  // @ts-ignore: decorator\n  @inline\n  const x: u8 = 0x78\n  // @ts-ignore: decorator\n  @inline\n  const y: u8 = 0x79\n  // @ts-ignore: decorator\n  @inline\n  const z: u8 = 0x7A\n  // @ts-ignore: decorator\n  @inline\n  const LBRACE: u8 = 0x7B\n  // @ts-ignore: decorator\n  @inline\n  const PIPE: u8 = 0x7C\n  // @ts-ignore: decorator\n  @inline\n  const RBRACE: u8 = 0x7D\n}\n","import { decRef, malloc } from './grainRuntime'\nimport { allocateString, singleByteString, stringSize } from './dataStructures'\nimport { GRAIN_GENERIC_HEAP_TAG_TYPE } from './tags';\nimport { CharCode } from './charCodes'\n\n/*\n * This file is a modified version of AssemblyScript's std/assembly/util/number.ts\n * Original file under Apache 2.0 License by AssemblyScript authors:\n *\n * https://github.com/AssemblyScript/assemblyscript/blob/d7ad4821a974d2491a0115cb35c85c649b34e7f0/LICENSE\n */\n\n// @ts-ignore: decorator\n//@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\nlet _POWERS10: usize = -1\n\nfunction get_POWERS10(): usize {\n  if (_POWERS10 == -1) {\n    _POWERS10 = <usize>(malloc(10 * 4))\n    store<u32>(_POWERS10, 1, 0 * 4)\n    store<u32>(_POWERS10, 10, 1 * 4)\n    store<u32>(_POWERS10, 100, 2 * 4)\n    store<u32>(_POWERS10, 1000, 3 * 4)\n    store<u32>(_POWERS10, 10000, 4 * 4)\n    store<u32>(_POWERS10, 100000, 5 * 4)\n    store<u32>(_POWERS10, 1000000, 6 * 4)\n    store<u32>(_POWERS10, 10000000, 7 * 4)\n    store<u32>(_POWERS10, 100000000, 8 * 4)\n    store<u32>(_POWERS10, 1000000000, 9 * 4)\n  }\n  return _POWERS10\n}\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\nlet _DIGITS: usize = -1\n\nfunction get_DIGITS(): usize {\n  if (_DIGITS == -1) {\n    _DIGITS = <usize>(malloc(100 * 4))\n    store<u32>(_DIGITS, 0x00300030, 0 * 4)\n    store<u32>(_DIGITS, 0x00310030, 1 * 4)\n    store<u32>(_DIGITS, 0x00320030, 2 * 4)\n    store<u32>(_DIGITS, 0x00330030, 3 * 4)\n    store<u32>(_DIGITS, 0x00340030, 4 * 4)\n    store<u32>(_DIGITS, 0x00350030, 5 * 4)\n    store<u32>(_DIGITS, 0x00360030, 6 * 4)\n    store<u32>(_DIGITS, 0x00370030, 7 * 4)\n    store<u32>(_DIGITS, 0x00380030, 8 * 4)\n    store<u32>(_DIGITS, 0x00390030, 9 * 4)\n    store<u32>(_DIGITS, 0x00300031, 10 * 4)\n    store<u32>(_DIGITS, 0x00310031, 11 * 4)\n    store<u32>(_DIGITS, 0x00320031, 12 * 4)\n    store<u32>(_DIGITS, 0x00330031, 13 * 4)\n    store<u32>(_DIGITS, 0x00340031, 14 * 4)\n    store<u32>(_DIGITS, 0x00350031, 15 * 4)\n    store<u32>(_DIGITS, 0x00360031, 16 * 4)\n    store<u32>(_DIGITS, 0x00370031, 17 * 4)\n    store<u32>(_DIGITS, 0x00380031, 18 * 4)\n    store<u32>(_DIGITS, 0x00390031, 19 * 4)\n    store<u32>(_DIGITS, 0x00300032, 20 * 4)\n    store<u32>(_DIGITS, 0x00310032, 21 * 4)\n    store<u32>(_DIGITS, 0x00320032, 22 * 4)\n    store<u32>(_DIGITS, 0x00330032, 23 * 4)\n    store<u32>(_DIGITS, 0x00340032, 24 * 4)\n    store<u32>(_DIGITS, 0x00350032, 25 * 4)\n    store<u32>(_DIGITS, 0x00360032, 26 * 4)\n    store<u32>(_DIGITS, 0x00370032, 27 * 4)\n    store<u32>(_DIGITS, 0x00380032, 28 * 4)\n    store<u32>(_DIGITS, 0x00390032, 29 * 4)\n    store<u32>(_DIGITS, 0x00300033, 30 * 4)\n    store<u32>(_DIGITS, 0x00310033, 31 * 4)\n    store<u32>(_DIGITS, 0x00320033, 32 * 4)\n    store<u32>(_DIGITS, 0x00330033, 33 * 4)\n    store<u32>(_DIGITS, 0x00340033, 34 * 4)\n    store<u32>(_DIGITS, 0x00350033, 35 * 4)\n    store<u32>(_DIGITS, 0x00360033, 36 * 4)\n    store<u32>(_DIGITS, 0x00370033, 37 * 4)\n    store<u32>(_DIGITS, 0x00380033, 38 * 4)\n    store<u32>(_DIGITS, 0x00390033, 39 * 4)\n    store<u32>(_DIGITS, 0x00300034, 40 * 4)\n    store<u32>(_DIGITS, 0x00310034, 41 * 4)\n    store<u32>(_DIGITS, 0x00320034, 42 * 4)\n    store<u32>(_DIGITS, 0x00330034, 43 * 4)\n    store<u32>(_DIGITS, 0x00340034, 44 * 4)\n    store<u32>(_DIGITS, 0x00350034, 45 * 4)\n    store<u32>(_DIGITS, 0x00360034, 46 * 4)\n    store<u32>(_DIGITS, 0x00370034, 47 * 4)\n    store<u32>(_DIGITS, 0x00380034, 48 * 4)\n    store<u32>(_DIGITS, 0x00390034, 49 * 4)\n    store<u32>(_DIGITS, 0x00300035, 50 * 4)\n    store<u32>(_DIGITS, 0x00310035, 51 * 4)\n    store<u32>(_DIGITS, 0x00320035, 52 * 4)\n    store<u32>(_DIGITS, 0x00330035, 53 * 4)\n    store<u32>(_DIGITS, 0x00340035, 54 * 4)\n    store<u32>(_DIGITS, 0x00350035, 55 * 4)\n    store<u32>(_DIGITS, 0x00360035, 56 * 4)\n    store<u32>(_DIGITS, 0x00370035, 57 * 4)\n    store<u32>(_DIGITS, 0x00380035, 58 * 4)\n    store<u32>(_DIGITS, 0x00390035, 59 * 4)\n    store<u32>(_DIGITS, 0x00300036, 60 * 4)\n    store<u32>(_DIGITS, 0x00310036, 61 * 4)\n    store<u32>(_DIGITS, 0x00320036, 62 * 4)\n    store<u32>(_DIGITS, 0x00330036, 63 * 4)\n    store<u32>(_DIGITS, 0x00340036, 64 * 4)\n    store<u32>(_DIGITS, 0x00350036, 65 * 4)\n    store<u32>(_DIGITS, 0x00360036, 66 * 4)\n    store<u32>(_DIGITS, 0x00370036, 67 * 4)\n    store<u32>(_DIGITS, 0x00380036, 68 * 4)\n    store<u32>(_DIGITS, 0x00390036, 69 * 4)\n    store<u32>(_DIGITS, 0x00300037, 70 * 4)\n    store<u32>(_DIGITS, 0x00310037, 71 * 4)\n    store<u32>(_DIGITS, 0x00320037, 72 * 4)\n    store<u32>(_DIGITS, 0x00330037, 73 * 4)\n    store<u32>(_DIGITS, 0x00340037, 74 * 4)\n    store<u32>(_DIGITS, 0x00350037, 75 * 4)\n    store<u32>(_DIGITS, 0x00360037, 76 * 4)\n    store<u32>(_DIGITS, 0x00370037, 77 * 4)\n    store<u32>(_DIGITS, 0x00380037, 78 * 4)\n    store<u32>(_DIGITS, 0x00390037, 79 * 4)\n    store<u32>(_DIGITS, 0x00300038, 80 * 4)\n    store<u32>(_DIGITS, 0x00310038, 81 * 4)\n    store<u32>(_DIGITS, 0x00320038, 82 * 4)\n    store<u32>(_DIGITS, 0x00330038, 83 * 4)\n    store<u32>(_DIGITS, 0x00340038, 84 * 4)\n    store<u32>(_DIGITS, 0x00350038, 85 * 4)\n    store<u32>(_DIGITS, 0x00360038, 86 * 4)\n    store<u32>(_DIGITS, 0x00370038, 87 * 4)\n    store<u32>(_DIGITS, 0x00380038, 88 * 4)\n    store<u32>(_DIGITS, 0x00390038, 89 * 4)\n    store<u32>(_DIGITS, 0x00300039, 90 * 4)\n    store<u32>(_DIGITS, 0x00310039, 91 * 4)\n    store<u32>(_DIGITS, 0x00320039, 92 * 4)\n    store<u32>(_DIGITS, 0x00330039, 93 * 4)\n    store<u32>(_DIGITS, 0x00340039, 94 * 4)\n    store<u32>(_DIGITS, 0x00350039, 95 * 4)\n    store<u32>(_DIGITS, 0x00360039, 96 * 4)\n    store<u32>(_DIGITS, 0x00370039, 97 * 4)\n    store<u32>(_DIGITS, 0x00380039, 98 * 4)\n    store<u32>(_DIGITS, 0x00390039, 99 * 4)\n  }\n  return _DIGITS\n}\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\nlet _HEX_DIGITS: usize = -1\n\nfunction get_HEX_DIGITS(): usize {\n  if (_HEX_DIGITS == -1) {\n    _HEX_DIGITS = <usize>(malloc(256 << 2))\n    store<u32>(_HEX_DIGITS, 0x00300030, 0 * 4) // 00\n    store<u32>(_HEX_DIGITS, 0x00310030, 1 * 4) // 01\n    store<u32>(_HEX_DIGITS, 0x00320030, 2 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330030, 3 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340030, 4 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350030, 5 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360030, 6 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370030, 7 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380030, 8 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390030, 9 * 4) // 09\n    store<u32>(_HEX_DIGITS, 0x00610030, 10 * 4) // 0a\n    store<u32>(_HEX_DIGITS, 0x00620030, 11 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630030, 12 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640030, 13 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650030, 14 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660030, 15 * 4) // 0f\n\n    store<u32>(_HEX_DIGITS, 0x00300031, 16 * 4) // 10\n    store<u32>(_HEX_DIGITS, 0x00310031, 17 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320031, 18 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330031, 19 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340031, 20 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350031, 21 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360031, 22 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370031, 23 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380031, 24 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390031, 25 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610031, 26 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620031, 27 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630031, 28 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640031, 29 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650031, 30 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660031, 31 * 4) // 1f\n\n    store<u32>(_HEX_DIGITS, 0x00300032, 32 * 4) // 20\n    store<u32>(_HEX_DIGITS, 0x00310032, 33 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320032, 34 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330032, 35 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340032, 36 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350032, 37 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360032, 38 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370032, 39 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380032, 40 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390032, 41 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610032, 42 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620032, 43 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630032, 44 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640032, 45 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650032, 46 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660032, 47 * 4) // 2f\n\n    store<u32>(_HEX_DIGITS, 0x00300033, 48 * 4) // 30\n    store<u32>(_HEX_DIGITS, 0x00310033, 49 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320033, 50 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330033, 51 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340033, 52 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350033, 53 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360033, 54 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370033, 55 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380033, 56 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390033, 57 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610033, 58 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620033, 59 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630033, 60 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640033, 61 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650033, 62 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660033, 63 * 4) // 3f\n\n    store<u32>(_HEX_DIGITS, 0x00300034, 64 * 4) // 40\n    store<u32>(_HEX_DIGITS, 0x00310034, 65 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320034, 66 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330034, 67 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340034, 68 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350034, 69 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360034, 70 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370034, 71 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380034, 72 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390034, 73 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610034, 74 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620034, 75 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630034, 76 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640034, 77 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650034, 78 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660034, 79 * 4) // 4f\n\n    store<u32>(_HEX_DIGITS, 0x00300035, 80 * 4) // 50\n    store<u32>(_HEX_DIGITS, 0x00310035, 81 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320035, 82 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330035, 83 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340035, 84 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350035, 85 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360035, 86 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370035, 87 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380035, 88 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390035, 89 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610035, 90 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620035, 91 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630035, 92 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640035, 93 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650035, 94 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660035, 95 * 4) // 5f\n\n    store<u32>(_HEX_DIGITS, 0x00300036, 96 * 4) // 60\n    store<u32>(_HEX_DIGITS, 0x00310036, 97 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320036, 98 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330036, 99 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340036, 100 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350036, 101 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360036, 102 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370036, 103 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380036, 104 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390036, 105 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610036, 106 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620036, 107 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630036, 108 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640036, 109 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650036, 110 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660036, 111 * 4) // 6f\n\n    store<u32>(_HEX_DIGITS, 0x00300037, 112 * 4) // 70\n    store<u32>(_HEX_DIGITS, 0x00310037, 113 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320037, 114 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330037, 115 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340037, 116 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350037, 117 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360037, 118 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370037, 119 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380037, 120 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390037, 121 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610037, 122 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620037, 123 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630037, 124 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640037, 125 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650037, 126 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660037, 127 * 4) // 7f\n\n    store<u32>(_HEX_DIGITS, 0x00300038, 128 * 4) // 80\n    store<u32>(_HEX_DIGITS, 0x00310038, 129 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320038, 130 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330038, 131 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340038, 132 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350038, 133 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360038, 134 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370038, 135 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380038, 136 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390038, 137 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610038, 138 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620038, 139 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630038, 140 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640038, 141 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650038, 142 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660038, 143 * 4) // 8f\n\n    store<u32>(_HEX_DIGITS, 0x00300039, 144 * 4) // 90\n    store<u32>(_HEX_DIGITS, 0x00310039, 145 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320039, 146 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330039, 147 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340039, 148 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350039, 149 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360039, 150 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370039, 151 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380039, 152 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390039, 153 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610039, 154 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620039, 155 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630039, 156 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640039, 157 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650039, 158 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660039, 159 * 4) // 9f\n\n    store<u32>(_HEX_DIGITS, 0x00300061, 160 * 4) // a0\n    store<u32>(_HEX_DIGITS, 0x00310061, 161 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320061, 162 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330061, 163 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340061, 164 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350061, 165 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360061, 166 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370061, 167 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380061, 168 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390061, 169 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610061, 170 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620061, 171 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630061, 172 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640061, 173 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650061, 174 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660061, 175 * 4) // af\n\n    store<u32>(_HEX_DIGITS, 0x00300062, 176 * 4) // b0\n    store<u32>(_HEX_DIGITS, 0x00310062, 177 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320062, 178 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330062, 179 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340062, 180 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350062, 181 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360062, 182 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370062, 183 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380062, 184 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390062, 185 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610062, 186 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620062, 187 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630062, 188 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640062, 189 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650062, 190 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660062, 191 * 4) // bf\n\n    store<u32>(_HEX_DIGITS, 0x00300063, 192 * 4) // c0\n    store<u32>(_HEX_DIGITS, 0x00310063, 193 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320063, 194 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330063, 195 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340063, 196 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350063, 197 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360063, 198 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370063, 199 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380063, 200 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390063, 201 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610063, 202 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620063, 203 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630063, 204 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640063, 205 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650063, 206 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660063, 207 * 4) // cf\n\n    store<u32>(_HEX_DIGITS, 0x00300064, 208 * 4) // d0\n    store<u32>(_HEX_DIGITS, 0x00310064, 209 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320064, 210 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330064, 211 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340064, 212 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350064, 213 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360064, 214 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370064, 215 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380064, 216 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390064, 217 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610064, 218 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620064, 219 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630064, 220 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640064, 221 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650064, 222 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660064, 223 * 4) // df\n\n    store<u32>(_HEX_DIGITS, 0x00300065, 224 * 4) // e0\n    store<u32>(_HEX_DIGITS, 0x00310065, 225 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320065, 226 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330065, 227 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340065, 228 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350065, 229 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360065, 230 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370065, 231 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380065, 232 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390065, 233 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610065, 234 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620065, 235 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630065, 236 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640065, 237 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650065, 238 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660065, 239 * 4) // ef\n\n    store<u32>(_HEX_DIGITS, 0x00300066, 240 * 4) // f0\n    store<u32>(_HEX_DIGITS, 0x00310066, 241 * 4)\n    store<u32>(_HEX_DIGITS, 0x00320066, 242 * 4)\n    store<u32>(_HEX_DIGITS, 0x00330066, 243 * 4)\n    store<u32>(_HEX_DIGITS, 0x00340066, 244 * 4)\n    store<u32>(_HEX_DIGITS, 0x00350066, 245 * 4)\n    store<u32>(_HEX_DIGITS, 0x00360066, 246 * 4)\n    store<u32>(_HEX_DIGITS, 0x00370066, 247 * 4)\n    store<u32>(_HEX_DIGITS, 0x00380066, 248 * 4)\n    store<u32>(_HEX_DIGITS, 0x00390066, 249 * 4)\n    store<u32>(_HEX_DIGITS, 0x00610066, 250 * 4)\n    store<u32>(_HEX_DIGITS, 0x00620066, 251 * 4)\n    store<u32>(_HEX_DIGITS, 0x00630066, 252 * 4)\n    store<u32>(_HEX_DIGITS, 0x00640066, 253 * 4)\n    store<u32>(_HEX_DIGITS, 0x00650066, 254 * 4)\n    store<u32>(_HEX_DIGITS, 0x00660066, 255 * 4) // ff\n  }\n  return _HEX_DIGITS\n}\n\n// @ts-ignore: decorator\nlet _ANY_DIGITS: usize = -1;\n\nfunction get_ANY_DIGITS(): usize {\n  if (_ANY_DIGITS == -1) {\n    _ANY_DIGITS = <usize>(malloc(36 << 1))\n    store<u16>(_ANY_DIGITS, CharCode._0)\n    store<u16>(_ANY_DIGITS, CharCode._1, 2 * 1)\n    store<u16>(_ANY_DIGITS, CharCode._2, 2 * 2)\n    store<u16>(_ANY_DIGITS, CharCode._3, 2 * 3)\n    store<u16>(_ANY_DIGITS, CharCode._4, 2 * 4)\n    store<u16>(_ANY_DIGITS, CharCode._5, 2 * 5)\n    store<u16>(_ANY_DIGITS, CharCode._6, 2 * 6)\n    store<u16>(_ANY_DIGITS, CharCode._7, 2 * 7)\n    store<u16>(_ANY_DIGITS, CharCode._8, 2 * 8)\n    store<u16>(_ANY_DIGITS, CharCode._9, 2 * 9)\n    store<u16>(_ANY_DIGITS, CharCode.a, 2 * 10)\n    store<u16>(_ANY_DIGITS, CharCode.b, 2 * 11)\n    store<u16>(_ANY_DIGITS, CharCode.c, 2 * 12)\n    store<u16>(_ANY_DIGITS, CharCode.d, 2 * 13)\n    store<u16>(_ANY_DIGITS, CharCode.e, 2 * 14)\n    store<u16>(_ANY_DIGITS, CharCode.f, 2 * 15)\n    store<u16>(_ANY_DIGITS, CharCode.g, 2 * 16)\n    store<u16>(_ANY_DIGITS, CharCode.h, 2 * 17)\n    store<u16>(_ANY_DIGITS, CharCode.i, 2 * 18)\n    store<u16>(_ANY_DIGITS, CharCode.j, 2 * 19)\n    store<u16>(_ANY_DIGITS, CharCode.k, 2 * 20)\n    store<u16>(_ANY_DIGITS, CharCode.l, 2 * 21)\n    store<u16>(_ANY_DIGITS, CharCode.m, 2 * 22)\n    store<u16>(_ANY_DIGITS, CharCode.n, 2 * 23)\n    store<u16>(_ANY_DIGITS, CharCode.o, 2 * 24)\n    store<u16>(_ANY_DIGITS, CharCode.p, 2 * 25)\n    store<u16>(_ANY_DIGITS, CharCode.q, 2 * 26)\n    store<u16>(_ANY_DIGITS, CharCode.r, 2 * 27)\n    store<u16>(_ANY_DIGITS, CharCode.s, 2 * 28)\n    store<u16>(_ANY_DIGITS, CharCode.t, 2 * 29)\n    store<u16>(_ANY_DIGITS, CharCode.u, 2 * 30)\n    store<u16>(_ANY_DIGITS, CharCode.v, 2 * 31)\n    store<u16>(_ANY_DIGITS, CharCode.w, 2 * 32)\n    store<u16>(_ANY_DIGITS, CharCode.x, 2 * 33)\n    store<u16>(_ANY_DIGITS, CharCode.y, 2 * 34)\n    store<u16>(_ANY_DIGITS, CharCode.z, 2 * 35)\n  }\n  return _ANY_DIGITS\n}\n\n// @ts-ignore: decorator\nlet _EXP_POWERS: usize = -1\n\nfunction get_EXP_POWERS(): usize {\n  if (_EXP_POWERS == -1) {\n    _EXP_POWERS = <usize>(malloc(87 * 2))\n    store<i16>(_EXP_POWERS, -1220, 0 * 2)\n    store<i16>(_EXP_POWERS, -1193, 1 * 2)\n    store<i16>(_EXP_POWERS, -1166, 2 * 2)\n    store<i16>(_EXP_POWERS, -1140, 3 * 2)\n    store<i16>(_EXP_POWERS, -1113, 4 * 2)\n    store<i16>(_EXP_POWERS, -1087, 5 * 2)\n    store<i16>(_EXP_POWERS, -1060, 6 * 2)\n    store<i16>(_EXP_POWERS, -1034, 7 * 2)\n    store<i16>(_EXP_POWERS, -1007, 8 * 2)\n    store<i16>(_EXP_POWERS, -980, 9 * 2)\n    store<i16>(_EXP_POWERS, -954, 10 * 2)\n    store<i16>(_EXP_POWERS, -927, 11 * 2)\n    store<i16>(_EXP_POWERS, -901, 12 * 2)\n    store<i16>(_EXP_POWERS, -874, 13 * 2)\n    store<i16>(_EXP_POWERS, -847, 14 * 2)\n    store<i16>(_EXP_POWERS, -821, 15 * 2)\n    store<i16>(_EXP_POWERS, -794, 16 * 2)\n    store<i16>(_EXP_POWERS, -768, 17 * 2)\n    store<i16>(_EXP_POWERS, -741, 18 * 2)\n    store<i16>(_EXP_POWERS, -715, 19 * 2)\n    store<i16>(_EXP_POWERS, -688, 20 * 2)\n    store<i16>(_EXP_POWERS, -661, 21 * 2)\n    store<i16>(_EXP_POWERS, -635, 22 * 2)\n    store<i16>(_EXP_POWERS, -608, 23 * 2)\n    store<i16>(_EXP_POWERS, -582, 24 * 2)\n    store<i16>(_EXP_POWERS, -555, 25 * 2)\n    store<i16>(_EXP_POWERS, -529, 26 * 2)\n    store<i16>(_EXP_POWERS, -502, 27 * 2)\n    store<i16>(_EXP_POWERS, -475, 28 * 2)\n    store<i16>(_EXP_POWERS, -449, 29 * 2)\n    store<i16>(_EXP_POWERS, -422, 30 * 2)\n    store<i16>(_EXP_POWERS, -396, 31 * 2)\n    store<i16>(_EXP_POWERS, -369, 32 * 2)\n    store<i16>(_EXP_POWERS, -343, 33 * 2)\n    store<i16>(_EXP_POWERS, -316, 34 * 2)\n    store<i16>(_EXP_POWERS, -289, 35 * 2)\n    store<i16>(_EXP_POWERS, -263, 36 * 2)\n    store<i16>(_EXP_POWERS, -236, 37 * 2)\n    store<i16>(_EXP_POWERS, -210, 38 * 2)\n    store<i16>(_EXP_POWERS, -183, 39 * 2)\n    store<i16>(_EXP_POWERS, -157, 40 * 2)\n    store<i16>(_EXP_POWERS, -130, 41 * 2)\n    store<i16>(_EXP_POWERS, -103, 42 * 2)\n    store<i16>(_EXP_POWERS, -77, 43 * 2)\n    store<i16>(_EXP_POWERS, -50, 44 * 2)\n    store<i16>(_EXP_POWERS, -24, 45 * 2)\n    store<i16>(_EXP_POWERS, 3, 46 * 2)\n    store<i16>(_EXP_POWERS, 30, 47 * 2)\n    store<i16>(_EXP_POWERS, 56, 48 * 2)\n    store<i16>(_EXP_POWERS, 83, 49 * 2)\n    store<i16>(_EXP_POWERS, 109, 50 * 2)\n    store<i16>(_EXP_POWERS, 136, 51 * 2)\n    store<i16>(_EXP_POWERS, 162, 52 * 2)\n    store<i16>(_EXP_POWERS, 189, 53 * 2)\n    store<i16>(_EXP_POWERS, 216, 54 * 2)\n    store<i16>(_EXP_POWERS, 242, 55 * 2)\n    store<i16>(_EXP_POWERS, 269, 56 * 2)\n    store<i16>(_EXP_POWERS, 295, 57 * 2)\n    store<i16>(_EXP_POWERS, 322, 58 * 2)\n    store<i16>(_EXP_POWERS, 348, 59 * 2)\n    store<i16>(_EXP_POWERS, 375, 60 * 2)\n    store<i16>(_EXP_POWERS, 402, 61 * 2)\n    store<i16>(_EXP_POWERS, 428, 62 * 2)\n    store<i16>(_EXP_POWERS, 455, 63 * 2)\n    store<i16>(_EXP_POWERS, 481, 64 * 2)\n    store<i16>(_EXP_POWERS, 508, 65 * 2)\n    store<i16>(_EXP_POWERS, 534, 66 * 2)\n    store<i16>(_EXP_POWERS, 561, 67 * 2)\n    store<i16>(_EXP_POWERS, 588, 68 * 2)\n    store<i16>(_EXP_POWERS, 614, 69 * 2)\n    store<i16>(_EXP_POWERS, 641, 70 * 2)\n    store<i16>(_EXP_POWERS, 667, 71 * 2)\n    store<i16>(_EXP_POWERS, 694, 72 * 2)\n    store<i16>(_EXP_POWERS, 720, 73 * 2)\n    store<i16>(_EXP_POWERS, 747, 74 * 2)\n    store<i16>(_EXP_POWERS, 774, 75 * 2)\n    store<i16>(_EXP_POWERS, 800, 76 * 2)\n    store<i16>(_EXP_POWERS, 827, 77 * 2)\n    store<i16>(_EXP_POWERS, 853, 78 * 2)\n    store<i16>(_EXP_POWERS, 880, 79 * 2)\n    store<i16>(_EXP_POWERS, 907, 80 * 2)\n    store<i16>(_EXP_POWERS, 933, 81 * 2)\n    store<i16>(_EXP_POWERS, 960, 82 * 2)\n    store<i16>(_EXP_POWERS, 986, 83 * 2)\n    store<i16>(_EXP_POWERS, 1013, 84 * 2)\n    store<i16>(_EXP_POWERS, 1039, 85 * 2)\n    store<i16>(_EXP_POWERS, 1066, 86 * 2)\n  }\n  return _EXP_POWERS\n}\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\nlet _FRC_POWERS: usize = -1\n\nfunction get_FRC_POWERS(): usize {\n  if (_FRC_POWERS == -1) {\n    _FRC_POWERS = <usize>(malloc(87 * 8))\n    store<u64>(_FRC_POWERS, 0xFA8FD5A0081C0288, 0 * 8)\n    store<u64>(_FRC_POWERS, 0xBAAEE17FA23EBF76, 1 * 8)\n    store<u64>(_FRC_POWERS, 0x8B16FB203055AC76, 2 * 8)\n    store<u64>(_FRC_POWERS, 0xCF42894A5DCE35EA, 3 * 8)\n    store<u64>(_FRC_POWERS, 0x9A6BB0AA55653B2D, 4 * 8)\n    store<u64>(_FRC_POWERS, 0xE61ACF033D1A45DF, 5 * 8)\n    store<u64>(_FRC_POWERS, 0xAB70FE17C79AC6CA, 6 * 8)\n    store<u64>(_FRC_POWERS, 0xFF77B1FCBEBCDC4F, 7 * 8)\n    store<u64>(_FRC_POWERS, 0xBE5691EF416BD60C, 8 * 8)\n    store<u64>(_FRC_POWERS, 0x8DD01FAD907FFC3C, 9 * 8)\n    store<u64>(_FRC_POWERS, 0xD3515C2831559A83, 10 * 8)\n    store<u64>(_FRC_POWERS, 0x9D71AC8FADA6C9B5, 11 * 8)\n    store<u64>(_FRC_POWERS, 0xEA9C227723EE8BCB, 12 * 8)\n    store<u64>(_FRC_POWERS, 0xAECC49914078536D, 13 * 8)\n    store<u64>(_FRC_POWERS, 0x823C12795DB6CE57, 14 * 8)\n    store<u64>(_FRC_POWERS, 0xC21094364DFB5637, 15 * 8)\n    store<u64>(_FRC_POWERS, 0x9096EA6F3848984F, 16 * 8)\n    store<u64>(_FRC_POWERS, 0xD77485CB25823AC7, 17 * 8)\n    store<u64>(_FRC_POWERS, 0xA086CFCD97BF97F4, 18 * 8)\n    store<u64>(_FRC_POWERS, 0xEF340A98172AACE5, 19 * 8)\n    store<u64>(_FRC_POWERS, 0xB23867FB2A35B28E, 20 * 8)\n    store<u64>(_FRC_POWERS, 0x84C8D4DFD2C63F3B, 21 * 8)\n    store<u64>(_FRC_POWERS, 0xC5DD44271AD3CDBA, 22 * 8)\n    store<u64>(_FRC_POWERS, 0x936B9FCEBB25C996, 23 * 8)\n    store<u64>(_FRC_POWERS, 0xDBAC6C247D62A584, 24 * 8)\n    store<u64>(_FRC_POWERS, 0xA3AB66580D5FDAF6, 25 * 8)\n    store<u64>(_FRC_POWERS, 0xF3E2F893DEC3F126, 26 * 8)\n    store<u64>(_FRC_POWERS, 0xB5B5ADA8AAFF80B8, 27 * 8)\n    store<u64>(_FRC_POWERS, 0x87625F056C7C4A8B, 28 * 8)\n    store<u64>(_FRC_POWERS, 0xC9BCFF6034C13053, 29 * 8)\n    store<u64>(_FRC_POWERS, 0x964E858C91BA2655, 30 * 8)\n    store<u64>(_FRC_POWERS, 0xDFF9772470297EBD, 31 * 8)\n    store<u64>(_FRC_POWERS, 0xA6DFBD9FB8E5B88F, 32 * 8)\n    store<u64>(_FRC_POWERS, 0xF8A95FCF88747D94, 33 * 8)\n    store<u64>(_FRC_POWERS, 0xB94470938FA89BCF, 34 * 8)\n    store<u64>(_FRC_POWERS, 0x8A08F0F8BF0F156B, 35 * 8)\n    store<u64>(_FRC_POWERS, 0xCDB02555653131B6, 36 * 8)\n    store<u64>(_FRC_POWERS, 0x993FE2C6D07B7FAC, 37 * 8)\n    store<u64>(_FRC_POWERS, 0xE45C10C42A2B3B06, 38 * 8)\n    store<u64>(_FRC_POWERS, 0xAA242499697392D3, 39 * 8)\n    store<u64>(_FRC_POWERS, 0xFD87B5F28300CA0E, 40 * 8)\n    store<u64>(_FRC_POWERS, 0xBCE5086492111AEB, 41 * 8)\n    store<u64>(_FRC_POWERS, 0x8CBCCC096F5088CC, 42 * 8)\n    store<u64>(_FRC_POWERS, 0xD1B71758E219652C, 43 * 8)\n    store<u64>(_FRC_POWERS, 0x9C40000000000000, 44 * 8)\n    store<u64>(_FRC_POWERS, 0xE8D4A51000000000, 45 * 8)\n    store<u64>(_FRC_POWERS, 0xAD78EBC5AC620000, 46 * 8)\n    store<u64>(_FRC_POWERS, 0x813F3978F8940984, 47 * 8)\n    store<u64>(_FRC_POWERS, 0xC097CE7BC90715B3, 48 * 8)\n    store<u64>(_FRC_POWERS, 0x8F7E32CE7BEA5C70, 49 * 8)\n    store<u64>(_FRC_POWERS, 0xD5D238A4ABE98068, 50 * 8)\n    store<u64>(_FRC_POWERS, 0x9F4F2726179A2245, 51 * 8)\n    store<u64>(_FRC_POWERS, 0xED63A231D4C4FB27, 52 * 8)\n    store<u64>(_FRC_POWERS, 0xB0DE65388CC8ADA8, 53 * 8)\n    store<u64>(_FRC_POWERS, 0x83C7088E1AAB65DB, 54 * 8)\n    store<u64>(_FRC_POWERS, 0xC45D1DF942711D9A, 55 * 8)\n    store<u64>(_FRC_POWERS, 0x924D692CA61BE758, 56 * 8)\n    store<u64>(_FRC_POWERS, 0xDA01EE641A708DEA, 57 * 8)\n    store<u64>(_FRC_POWERS, 0xA26DA3999AEF774A, 58 * 8)\n    store<u64>(_FRC_POWERS, 0xF209787BB47D6B85, 59 * 8)\n    store<u64>(_FRC_POWERS, 0xB454E4A179DD1877, 60 * 8)\n    store<u64>(_FRC_POWERS, 0x865B86925B9BC5C2, 61 * 8)\n    store<u64>(_FRC_POWERS, 0xC83553C5C8965D3D, 62 * 8)\n    store<u64>(_FRC_POWERS, 0x952AB45CFA97A0B3, 63 * 8)\n    store<u64>(_FRC_POWERS, 0xDE469FBD99A05FE3, 64 * 8)\n    store<u64>(_FRC_POWERS, 0xA59BC234DB398C25, 65 * 8)\n    store<u64>(_FRC_POWERS, 0xF6C69A72A3989F5C, 66 * 8)\n    store<u64>(_FRC_POWERS, 0xB7DCBF5354E9BECE, 67 * 8)\n    store<u64>(_FRC_POWERS, 0x88FCF317F22241E2, 68 * 8)\n    store<u64>(_FRC_POWERS, 0xCC20CE9BD35C78A5, 69 * 8)\n    store<u64>(_FRC_POWERS, 0x98165AF37B2153DF, 70 * 8)\n    store<u64>(_FRC_POWERS, 0xE2A0B5DC971F303A, 71 * 8)\n    store<u64>(_FRC_POWERS, 0xA8D9D1535CE3B396, 72 * 8)\n    store<u64>(_FRC_POWERS, 0xFB9B7CD9A4A7443C, 73 * 8)\n    store<u64>(_FRC_POWERS, 0xBB764C4CA7A44410, 74 * 8)\n    store<u64>(_FRC_POWERS, 0x8BAB8EEFB6409C1A, 75 * 8)\n    store<u64>(_FRC_POWERS, 0xD01FEF10A657842C, 76 * 8)\n    store<u64>(_FRC_POWERS, 0x9B10A4E5E9913129, 77 * 8)\n    store<u64>(_FRC_POWERS, 0xE7109BFBA19C0C9D, 78 * 8)\n    store<u64>(_FRC_POWERS, 0xAC2820D9623BF429, 79 * 8)\n    store<u64>(_FRC_POWERS, 0x80444B5E7AA7CF85, 80 * 8)\n    store<u64>(_FRC_POWERS, 0xBF21E44003ACDD2D, 81 * 8)\n    store<u64>(_FRC_POWERS, 0x8E679C2F5E44FF8F, 82 * 8)\n    store<u64>(_FRC_POWERS, 0xD433179D9C8CB841, 83 * 8)\n    store<u64>(_FRC_POWERS, 0x9E19DB92B4E31BA9, 84 * 8)\n    store<u64>(_FRC_POWERS, 0xEB96BF6EBADF77D9, 85 * 8)\n    store<u64>(_FRC_POWERS, 0xAF87023B9BF0EE6B, 86 * 8)\n  }\n  return _FRC_POWERS\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(get_DIGITS() + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(get_DIGITS() + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(get_DIGITS() + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(get_DIGITS() + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(get_DIGITS() + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(get_DIGITS() + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(get_DIGITS() + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(get_DIGITS() + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = get_HEX_DIGITS()\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = get_ANY_DIGITS();\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\n// This file produces JS (UTF-16) strings. We need to re-encode them as UTF-8 for Grain.\n// Note that all of the characters used in the strings produced in this file are ASCII,\n// so we can safely just halve the size of the string.\n// [TODO] (#475) Optimization: Make the functions in this file directly produce UTF-8\nfunction fixEncoding(utf16StringRaw: u32): u32 {\n  let utf16String = utf16StringRaw & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  let utf16Size = stringSize(utf16StringRaw)\n  let utf8Size = utf16Size >> 1\n  let ret = allocateString(utf8Size)\n  String.UTF8.encodeUnsafe(<usize>(utf16String + 8), utf8Size, ret + 8, false)\n  decRef(utf16StringRaw)\n  return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function utoa32(value: u32, radix: i32): u32 {\n  if (radix < 2 || radix > 36) {\n    //throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    throw new RangeError()\n  }\n  if (!value) return singleByteString(CharCode._0);\n  var out: u32 = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa32_dec_core(out + 8, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa32_hex_core(out + 8, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa64_any_core(out + 8, value, decimals, radix);\n  }\n  return fixEncoding(out); // retains\n}\n\nexport function itoa32(value: i32, radix: i32): u32 {\n  if (radix < 2 || radix > 36) {\n    //throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    throw new RangeError()\n  }\n  if (!value) return singleByteString(CharCode._0);\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: u32 = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa32_dec_core(<usize>(out + 8), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa32_hex_core(<usize>(out + 8), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa64_any_core(<usize>(out + 8), val32, decimals, radix);\n  }\n  if (sign) store<u16>(<usize>(out + 8), CharCode.MINUS);\n  let ret = fixEncoding(out); // retains\n  return ret\n}\n\nexport function utoa64(value: u64, radix: i32): u32 {\n  if (radix < 2 || radix > 36) {\n    //throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    throw new RangeError()\n  }\n  if (!value) return singleByteString(CharCode._0);\n  var out: u32 = 0;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n      out = allocateString(decimals << 1);\n      utoa32_dec_core(out + 8, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n      out = allocateString(decimals << 1);\n      utoa64_dec_core(out + 8, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa64_hex_core(out + 8, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = allocateString(decimals << 1);\n    utoa64_any_core(out + 8, value, decimals, radix);\n  }\n  return fixEncoding(out); // retains\n}\n\nexport function itoa64(value: i64, radix: i32): u32 {\n  if (radix < 2 || radix > 36) {\n    //throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    throw new RangeError()\n  }\n  if (!value) return singleByteString(CharCode._0);\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: u32 = 0;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n      out = allocateString(decimals << 1);\n      utoa32_dec_core(out + 8, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n      out = allocateString(decimals << 1);\n      utoa64_dec_core(out + 8, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa64_hex_core(out + 8, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    // (#475) Need to allocated twice the actual size for intermediate UTF-16 representation\n    out = allocateString(decimals << 1);\n    utoa64_any_core(out + 8, value, decimals, radix);\n  }\n  if (sign) store<u16>(out + 8, CharCode.MINUS);\n  return fixEncoding(out); // retains\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(get_FRC_POWERS() + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(get_EXP_POWERS() + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(get_POWERS10() + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(get_POWERS10() + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\nlet _dtoa_buf: usize = -1\n\nfunction get_dtoa_buf(): usize {\n  if (_dtoa_buf == -1) {\n    _dtoa_buf = <usize>(malloc(MAX_DOUBLE_LENGTH << 1))\n  }\n  return _dtoa_buf\n}\n\nexport function dtoa(value: f64): u32 {\n  if (value == 0) {\n    let ret = allocateString(3)\n    store<u8>(ret, CharCode._0, 8)\n    store<u8>(ret, CharCode.DOT, 8 + 1)\n    store<u8>(ret, CharCode._0, 8 + 2)\n    return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n  } else if (!isFinite(value)) {\n    if (isNaN(value)) {\n      let ret = allocateString(3)\n      store<u8>(ret, CharCode.N, 8)\n      store<u8>(ret, CharCode.a, 8 + 1)\n      store<u8>(ret, CharCode.N, 8 + 2)\n      return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n    } else if (value < 0) {\n      let ret = allocateString(9)\n      store<u8>(ret, CharCode.MINUS, 8)\n      store<u8>(ret, CharCode.I, 8 + 1)\n      store<u8>(ret, CharCode.n, 8 + 2)\n      store<u8>(ret, CharCode.f, 8 + 3)\n      store<u8>(ret, CharCode.i, 8 + 4)\n      store<u8>(ret, CharCode.n, 8 + 5)\n      store<u8>(ret, CharCode.i, 8 + 6)\n      store<u8>(ret, CharCode.t, 8 + 7)\n      store<u8>(ret, CharCode.y, 8 + 8)\n      return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n    } else {\n      let ret = allocateString(8)\n      store<u8>(ret, CharCode.I, 8)\n      store<u8>(ret, CharCode.n, 8 + 1)\n      store<u8>(ret, CharCode.f, 8 + 2)\n      store<u8>(ret, CharCode.i, 8 + 3)\n      store<u8>(ret, CharCode.n, 8 + 4)\n      store<u8>(ret, CharCode.i, 8 + 5)\n      store<u8>(ret, CharCode.t, 8 + 6)\n      store<u8>(ret, CharCode.y, 8 + 7)\n      return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n    }\n  }\n  var size = dtoa_core(get_dtoa_buf(), value);\n  var result = allocateString(size);\n  String.UTF8.encodeUnsafe(get_dtoa_buf(), size, result + 8, false)\n  return result | GRAIN_GENERIC_HEAP_TAG_TYPE;\n}\n\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","export const GRAIN_ERR_NOT_NUMBER_COMP: u32 = 0\nexport const GRAIN_ERR_NOT_NUMBER_ARITH: u32 = 1\nexport const GRAIN_ERR_NOT_BOOLEAN_LOGIC: u32 = 2\nexport const GRAIN_ERR_NOT_BOOLEAN_IF: u32 = 3\nexport const GRAIN_ERR_OVERFLOW: u32 = 4\nexport const GRAIN_ERR_GET_NOT_TUP: u32 = 5\nexport const GRAIN_ERR_GET_ITEM_IDX_NOT_NUMBER: u32 = 6\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_SMALL: u32 = 7\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_LARGE: u32 = 8\nexport const GRAIN_ERR_CALLED_NON_FUNCTION: u32 = 9\nexport const GRAIN_ERR_ARITY_MISMATCH: u32 = 10\nexport const GRAIN_ERR_OUT_OF_MEMORY: u32 = 11\nexport const GRAIN_ERR_SET_NOT_TUP: u32 = 12\nexport const GRAIN_ERR_SET_ITEM_IDX_NOT_NUMBER: u32 = 13\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_SMALL: u32 = 14\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_LARGE: u32 = 15\nexport const GRAIN_ERR_DIVISION_BY_ZERO: u32 = 17\nexport const GRAIN_ERR_MODULO_BY_ZERO: u32 = 18\nexport const GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS: u32 = 19\nexport const GRAIN_ERR_INVALID_ARGUMENT: u32 = 20\nexport const GRAIN_ERR_ASSERTION_ERROR: u32 = 21\nexport const GRAIN_ERR_FAILURE: u32 = 22\nexport const GRAIN_ERR_SYSTEM: u32 = 23\nexport const GRAIN_ERR_NOT_INTLIKE: u32 = 24\nexport const GRAIN_ERR_NOT_RATIONAL: u32 = 25\nexport const GRAIN_ERR_MALFORMED_UTF8: u32 = 26\nexport const GRAIN_ERR_NOT_ADT_VAL_GENERIC: u32 = 91\nexport const GRAIN_ERR_NOT_STRING_GENERIC: u32 = 93\nexport const GRAIN_ERR_NOT_BOOLEAN_GENERIC: u32 = 94\nexport const GRAIN_ERR_NOT_TUPLE_GENERIC: u32 = 95\nexport const GRAIN_ERR_NOT_LAMBDA_GENERIC: u32 = 96\nexport const GRAIN_ERR_BAD_INPUT: u32 = 97\nexport const GRAIN_ERR_NOT_NONNEG: u32 = 98\nexport const GRAIN_ERR_NOT_NUMBER_GENERIC: u32 = 99\n","import {\n  GRAIN_NUMBER_TAG_TYPE,\n  GRAIN_CONST_TAG_TYPE,\n  GRAIN_TUPLE_TAG_TYPE,\n  GRAIN_LAMBDA_TAG_TYPE,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n\n  GRAIN_NUMBER_TAG_MASK,\n  GRAIN_GENERIC_TAG_MASK,\n\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_ADT_HEAP_TAG,\n  GRAIN_RECORD_HEAP_TAG,\n  GRAIN_ARRAY_HEAP_TAG,\n} from './ascutils/tags'\n\nimport {\n  GRAIN_TRUE,\n  GRAIN_FALSE,\n} from './ascutils/primitives'\n\nimport { isNumber, numberEqual } from './numbers'\n\nconst cycleMarker: u32 = 0x80000000\n\nfunction heapEqualHelp(heapTag: u32, xptr: u32, yptr: u32): bool {\n  switch (heapTag) {\n    case GRAIN_ADT_HEAP_TAG: {\n      // Check if the same constructor variant\n      if (load<u32>(xptr, 3 * 4) !== load<u32>(yptr, 3 * 4)) {\n        return false\n      }\n\n      let xarity = load<u32>(xptr, 4 * 4)\n      let yarity = load<u32>(yptr, 4 * 4)\n\n      // Check that the arities are the same\n      if (xarity !== yarity) {\n        return false\n      }\n\n      // Cycle check\n      if ((xarity & cycleMarker) === cycleMarker) {\n        return true\n      }\n      store<u32>(xptr, xarity ^ cycleMarker, 4 * 4)\n      store<u32>(yptr, yarity ^ cycleMarker, 4 * 4)\n\n      let result = true\n\n      let bytes = xarity * 4\n      for (let i: u32 = 0; i < bytes; i += 4) {\n        if (!equalHelp(load<u32>(xptr + i, 5 * 4), load<u32>(yptr + i, 5 * 4))) {\n          result = false\n          break\n        }\n      }\n      store<u32>(xptr, xarity, 4 * 4)\n      store<u32>(yptr, yarity, 4 * 4)\n\n      return result\n    }\n    case GRAIN_RECORD_HEAP_TAG: {\n      let xlength = load<u32>(xptr, 3 * 4)\n      let ylength = load<u32>(yptr, 3 * 4)\n\n      // Check that the lengths are the same\n      if (xlength !== ylength) {\n        return false\n      }\n\n      // Cycle check\n      if ((xlength & cycleMarker) === cycleMarker) {\n        return true\n      }\n      store<u32>(xptr, xlength ^ cycleMarker, 3 * 4)\n      store<u32>(yptr, ylength ^ cycleMarker, 3 * 4)\n\n      let result = true\n\n      let bytes = xlength * 4\n      for (let i: u32 = 0; i < bytes; i += 4) {\n        if (!equalHelp(load<u32>(xptr + i, 4 * 4), load<u32>(yptr + i, 4 * 4))) {\n          result = false\n          break\n        }\n      }\n      store<u32>(xptr, xlength, 3 * 4)\n      store<u32>(yptr, ylength, 3 * 4)\n\n      return result\n    }\n    case GRAIN_ARRAY_HEAP_TAG: {\n      let xlength = load<u32>(xptr, 4)\n      let ylength = load<u32>(yptr, 4)\n\n      // Check if the same length\n      if (xlength !== ylength) {\n        return false\n      }\n\n      // Cycle check\n      if (xlength & cycleMarker) {\n        return true\n      }\n      store<u32>(xptr, xlength ^ cycleMarker, 4)\n      store<u32>(yptr, ylength ^ cycleMarker, 4)\n\n      let result = true\n      let bytes = xlength * 4\n      for (let i: u32 = 0; i < bytes; i += 4) {\n        if (!equalHelp(load<u32>(xptr + i, 2 * 4), load<u32>(yptr + i, 2 * 4))) {\n          result = false\n          break\n        }\n      }\n\n      store<u32>(xptr, xlength, 4)\n      store<u32>(yptr, ylength, 4)\n      return result\n    }\n    case GRAIN_STRING_HEAP_TAG: {\n      let xlength = load<u32>(xptr, 4)\n      let ylength = load<u32>(yptr, 4)\n\n      // Check if the same length\n      if (xlength !== ylength) {\n        return false\n      }\n\n      let extra = xlength % 8\n      let first = xlength - extra\n      for (let i: u32 = 0; i < first; i += 8) {\n        if (load<u64>(xptr + i, 2 * 4) !== load<u64>(yptr + i, 2 * 4)) {\n          return false\n        }\n      }\n      for (let i: u32 = 0; i < extra; i += 1) {\n        if (load<u8>(xptr + first + i, 2 * 4) !== load<u8>(yptr + first + i, 2 * 4)) {\n          return false\n        }\n      }\n\n      return true\n    }\n    case GRAIN_CHAR_HEAP_TAG: {\n      const byte = load<u8>(xptr, 4)\n      let n: u32\n      if ((byte & 0x80) === 0x00) {\n        n = 1\n      } else if ((byte & 0xF0) === 0xF0) {\n        n = 4\n      } else if ((byte & 0xE0) === 0xE0) {\n        n = 3\n      } else {\n        n = 2\n      }\n      if (memory.compare(xptr + 4, yptr + 4, n) === 0) {\n        return true\n      }\n      return false\n    }\n    default: {\n      // No other implementation\n      return xptr === yptr\n    }\n  }\n}\n\nfunction equalHelp(x: u32, y: u32): bool {\n  // Short circuit if value/pointer is the same\n  if (x === y) return true\n  if (isNumber(x)) return numberEqual(x, y)\n\n  // We only need to worry about heep allocated things since everything else\n  // is handled by a simple x == y check at the end\n  switch (x & GRAIN_GENERIC_TAG_MASK) {\n    case GRAIN_TUPLE_TAG_TYPE: {\n      let xptr = x ^ GRAIN_TUPLE_TAG_TYPE\n      let yptr = y ^ GRAIN_TUPLE_TAG_TYPE\n\n      let xsize = load<u32>(xptr)\n      let ysize = load<u32>(yptr)\n\n      if (xsize !== ysize) {\n        return false\n      }\n\n      if ((xsize & cycleMarker) === cycleMarker) {\n        return true\n      }\n\n      store<u32>(xptr, xsize ^ cycleMarker)\n      store<u32>(yptr, ysize ^ cycleMarker)\n\n      let result = true\n      let bytes = xsize * 4\n      for (let i: u32 = 0; i < bytes; i += 4) {\n        if (!equalHelp(load<u32>(xptr + i, 4), load<u32>(yptr + i, 4))) {\n          result = false\n          break\n        }\n      }\n\n      store<u32>(xptr, xsize)\n      store<u32>(yptr, ysize)\n\n      return result\n    }\n    case GRAIN_GENERIC_HEAP_TAG_TYPE: {\n      let xptr = x ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n      let yptr = y ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n      return heapEqualHelp(load<u32>(xptr), xptr, yptr)\n    }\n  }\n\n  return x === y\n}\n\nexport function equal(x: u32, y: u32): u32 {\n  return equalHelp(x, y) ? GRAIN_TRUE : GRAIN_FALSE\n}\n","import { GRAIN_ADT_HEAP_TAG, GRAIN_ARRAY_HEAP_TAG, GRAIN_GENERIC_HEAP_TAG_TYPE, GRAIN_RECORD_HEAP_TAG, GRAIN_CHAR_HEAP_TAG, GRAIN_STRING_HEAP_TAG, GRAIN_BOXED_NUM_HEAP_TAG, GRAIN_INT32_BOXED_NUM_TAG, GRAIN_INT64_BOXED_NUM_TAG, GRAIN_RATIONAL_BOXED_NUM_TAG, GRAIN_FLOAT32_BOXED_NUM_TAG, GRAIN_FLOAT64_BOXED_NUM_TAG, GRAIN_TUPLE_TAG_TYPE, GRAIN_LAMBDA_TAG_TYPE } from '../ascutils/tags'\nimport { stringSize, allocateString, loadInt32, loadInt64, loadFloat32, loadFloat64, loadRationalNumerator, loadRationalDenominator, singleByteString, twoByteString } from '../ascutils/dataStructures'\nimport { GRAIN_FALSE, GRAIN_TRUE, GRAIN_VOID } from '../ascutils/primitives'\nimport { incRef, decRef } from '../ascutils/grainRuntime'\nimport { dtoa, itoa32, itoa64 } from '../ascutils/numberUtils'\nimport { CharCode } from '../ascutils/charCodes'\nimport { equal } from '../equal'\n\n// Introspection helpers for to-string (will eventually be part of the AS runtime)\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"variantExists\")\ndeclare function variantExists(moduleId: u32, typeId: u32, variantId: u32): bool\n\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"getVariantName\")\ndeclare function getVariantName(moduleId: u32, typeId: u32, variantId: u32): u32\n\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"getVariantArity\")\ndeclare function getVariantArity(moduleId: u32, typeId: u32, variantId: u32): i32\n\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"recordTypeExists\")\ndeclare function recordTypeExists(moduleId: u32, typeId: u32): bool\n\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"getRecordArity\")\ndeclare function getRecordArity(moduleId: u32, typeId: u32): i32\n\n// @ts-ignore: decorator\n@external(\"grainRuntime\", \"getRecordFieldName\")\ndeclare function getRecordFieldName(moduleId: u32, typeId: u32, idx: u32): u32\n\n\nexport function concat(s1: u32, s2: u32): u32 {\n  s1 = s1 ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  s2 = s2 ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  const size1 = stringSize(s1)\n  const size2 = stringSize(s2)\n\n  const newString = allocateString(size1 + size2)\n\n  memory.copy(newString + 8, s1 + 8, size1)\n  memory.copy(newString + 8 + size1, s2 + 8, size2)\n\n  return newString ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction leftLiteralConcat1(c: u8, gs: u32): u32 {\n  gs = gs & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  const gsSize = stringSize(gs)\n  let newString = allocateString(gsSize + 1)\n  memory.copy(newString + 9, gs + 8, gsSize)\n  store<u8>(newString, c, 8)\n  return newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction leftLiteralConcat2(c1: u8, c2: u8, gs: u32): u32 {\n  gs = gs & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  const gsSize = stringSize(gs)\n  let newString = allocateString(gsSize + 2)\n  memory.copy(newString + 10, gs + 8, gsSize)\n  store<u8>(newString, c1, 8)\n  store<u8>(newString, c2, 9)\n  return newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n\n// @ts-ignore: decorator\n@inline\nfunction rightLiteralConcat1(gs: u32, c: u8): u32 {\n  gs = gs & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  const gsSize = stringSize(gs)\n  let newString = allocateString(gsSize + 1)\n  memory.copy(newString + 8, gs + 8, gsSize)\n  store<u8>(newString + 8 + gsSize, c)\n  return newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rightLiteralConcat2(gs: u32, c1: u8, c2: u8): u32 {\n  gs = gs & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  const gsSize = stringSize(gs)\n  let newString = allocateString(gsSize + 2)\n  memory.copy(newString + 8, gs + 8, gsSize)\n  store<u8>(newString + 8 + gsSize, c1)\n  store<u8>(newString + 8 + gsSize, c2, 1)\n  return newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nfunction grainListToString(ptr: u32, extraIndents: u32): u32 {\n  const untaggedPtr = ptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  let cur = untaggedPtr\n  let ret = singleByteString(CharCode.LBRACK)\n  let isFirst = true\n\n  while (true) {\n    let variantId = load<i32>(cur, 4 * 3) >> 1 // tagged number\n    if (variantId === 0) {\n      break;\n    } else {\n      if (!isFirst) {\n        let oldRet = ret\n        ret = rightLiteralConcat2(ret, CharCode.COMMA, CharCode.SPACE)\n        decRef(oldRet)\n      }\n      isFirst = false\n      let itemString = grainToStringHelp(load<u32>(cur, 4 * 5), extraIndents, false)\n      let oldRet = ret\n      ret = concat(ret, itemString)\n      decRef(oldRet)\n      cur = load<u32>(cur, 4 * 6) & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n    }\n  }\n  let oldRet = ret\n  ret = rightLiteralConcat1(ret, CharCode.RBRACK)\n  decRef(oldRet)\n  return ret\n}\n\n\nfunction quoteString(ptr: u32): u32 {\n  const untaggedPtr = ptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  let length = stringSize(untaggedPtr)\n  let ret = allocateString(length + 2)\n  store<u8>(ret + 8, CharCode.QUOTE)\n  memory.copy(ret + 9, untaggedPtr + 8, length)\n  store<u8>(ret + 9 + length, CharCode.QUOTE)\n  return ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// For performance, we intern the constants produced by grainHeapValueToString. This is handled here.\nlet ADT_VALUE_STRING: u32 = -1\nlet LIST_VARIANT_STRING: u32 = -1\nlet RECORD_VALUE_STRING: u32 = -1\nlet CYCLIC_TUPLE_STRING: u32 = -1\nlet LAMBDA_STRING: u32 = -1\nlet TRUE_STRING: u32 = -1\nlet FALSE_STRING: u32 = -1\nlet VOID_STRING: u32 = -1\nlet UNKNOWN_VALUE_STRING: u32 = -1\n\nfunction getAdtValueString(): u32 {\n  if (ADT_VALUE_STRING == <u32>(-1)) {\n    let newString = allocateString(11)\n    store<u8>(newString, CharCode.LANGLE, 8)\n    store<u8>(newString, CharCode.a, 8 + 1)\n    store<u8>(newString, CharCode.d, 8 + 2)\n    store<u8>(newString, CharCode.t, 8 + 3)\n    store<u8>(newString, CharCode.SPACE, 8 + 4)\n    store<u8>(newString, CharCode.v, 8 + 5)\n    store<u8>(newString, CharCode.a, 8 + 6)\n    store<u8>(newString, CharCode.l, 8 + 7)\n    store<u8>(newString, CharCode.u, 8 + 8)\n    store<u8>(newString, CharCode.e, 8 + 9)\n    store<u8>(newString, CharCode.RANGLE, 8 + 10)\n    ADT_VALUE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(ADT_VALUE_STRING) // <- avoid value getting GC'd\n  }\n  return ADT_VALUE_STRING\n}\n\n\nfunction getListVariantString(): u32 {\n  if (LIST_VARIANT_STRING == <u32>(-1)) {\n    let newString = allocateString(5)\n    store<u8>(newString, CharCode.LBRACK, 8)\n    store<u8>(newString, CharCode.DOT, 8 + 1)\n    store<u8>(newString, CharCode.DOT, 8 + 2)\n    store<u8>(newString, CharCode.DOT, 8 + 3)\n    store<u8>(newString, CharCode.RBRACK, 8 + 4)\n    LIST_VARIANT_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(LIST_VARIANT_STRING) // <- avoid value getting GC'd\n  }\n  return LIST_VARIANT_STRING\n}\n\n\nfunction getRecordValueString(): u32 {\n  if (RECORD_VALUE_STRING == <u32>(-1)) {\n    let newString = allocateString(14)\n    store<u8>(newString, CharCode.LANGLE, 8)\n    store<u8>(newString, CharCode.r, 8 + 1)\n    store<u8>(newString, CharCode.e, 8 + 2)\n    store<u8>(newString, CharCode.c, 8 + 3)\n    store<u8>(newString, CharCode.o, 8 + 4)\n    store<u8>(newString, CharCode.r, 8 + 5)\n    store<u8>(newString, CharCode.d, 8 + 6)\n    store<u8>(newString, CharCode.SPACE, 8 + 7)\n    store<u8>(newString, CharCode.v, 8 + 8)\n    store<u8>(newString, CharCode.a, 8 + 9)\n    store<u8>(newString, CharCode.l, 8 + 10)\n    store<u8>(newString, CharCode.u, 8 + 11)\n    store<u8>(newString, CharCode.e, 8 + 12)\n    store<u8>(newString, CharCode.RANGLE, 8 + 13)\n    RECORD_VALUE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(RECORD_VALUE_STRING) // <- avoid value getting GC'd\n  }\n  return RECORD_VALUE_STRING\n}\n\n\nfunction getCyclicTupleString(): u32 {\n  if (CYCLIC_TUPLE_STRING == <u32>(-1)) {\n    let newString = allocateString(14)\n    store<u8>(newString, CharCode.LANGLE, 8)\n    store<u8>(newString, CharCode.c, 8 + 1)\n    store<u8>(newString, CharCode.y, 8 + 2)\n    store<u8>(newString, CharCode.c, 8 + 3)\n    store<u8>(newString, CharCode.l, 8 + 4)\n    store<u8>(newString, CharCode.i, 8 + 5)\n    store<u8>(newString, CharCode.c, 8 + 6)\n    store<u8>(newString, CharCode.SPACE, 8 + 7)\n    store<u8>(newString, CharCode.t, 8 + 8)\n    store<u8>(newString, CharCode.u, 8 + 9)\n    store<u8>(newString, CharCode.p, 8 + 10)\n    store<u8>(newString, CharCode.l, 8 + 11)\n    store<u8>(newString, CharCode.e, 8 + 12)\n    store<u8>(newString, CharCode.RANGLE, 8 + 13)\n    CYCLIC_TUPLE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(CYCLIC_TUPLE_STRING) // <- avoid value getting GC'd\n  }\n  return CYCLIC_TUPLE_STRING\n}\n\n\nfunction getLambdaString(): u32 {\n  if (LAMBDA_STRING == <u32>(-1)) {\n    let newString = allocateString(8)\n    store<u8>(newString, CharCode.LANGLE, 8)\n    store<u8>(newString, CharCode.l, 8 + 1)\n    store<u8>(newString, CharCode.a, 8 + 2)\n    store<u8>(newString, CharCode.m, 8 + 3)\n    store<u8>(newString, CharCode.b, 8 + 4)\n    store<u8>(newString, CharCode.d, 8 + 5)\n    store<u8>(newString, CharCode.a, 8 + 6)\n    store<u8>(newString, CharCode.RANGLE, 8 + 7)\n    LAMBDA_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(LAMBDA_STRING) // <- avoid value getting GC'd\n  }\n  return LAMBDA_STRING\n}\n\n\nfunction getTrueString(): u32 {\n  if (TRUE_STRING == <u32>(-1)) {\n    let newString = allocateString(4)\n    store<u8>(newString, CharCode.t, 8)\n    store<u8>(newString, CharCode.r, 8 + 1)\n    store<u8>(newString, CharCode.u, 8 + 2)\n    store<u8>(newString, CharCode.e, 8 + 3)\n    TRUE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(TRUE_STRING) // <- avoid value getting GC'd\n  }\n  return TRUE_STRING\n}\n\n\nfunction getFalseString(): u32 {\n  if (FALSE_STRING == <u32>(-1)) {\n    let newString = allocateString(5)\n    store<u8>(newString, CharCode.f, 8)\n    store<u8>(newString, CharCode.a, 8 + 1)\n    store<u8>(newString, CharCode.l, 8 + 2)\n    store<u8>(newString, CharCode.s, 8 + 3)\n    store<u8>(newString, CharCode.e, 8 + 4)\n    FALSE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(FALSE_STRING) // <- avoid value getting GC'd\n  }\n  return FALSE_STRING\n}\n\n\nfunction getVoidString(): u32 {\n  if (VOID_STRING == <u32>(-1)) {\n    let newString = allocateString(4)\n    store<u8>(newString, CharCode.v, 8)\n    store<u8>(newString, CharCode.o, 8 + 1)\n    store<u8>(newString, CharCode.i, 8 + 2)\n    store<u8>(newString, CharCode.d, 8 + 3)\n    VOID_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(VOID_STRING) // <- avoid value getting GC'd\n  }\n  return VOID_STRING\n}\n\n\nfunction getUnknownValueString(): u32 {\n  if (UNKNOWN_VALUE_STRING == <u32>(-1)) {\n    let newString = allocateString(15)\n    store<u8>(newString, CharCode.LANGLE, 8)\n    store<u8>(newString, CharCode.U, 8 + 1)\n    store<u8>(newString, CharCode.n, 8 + 2)\n    store<u8>(newString, CharCode.k, 8 + 3)\n    store<u8>(newString, CharCode.n, 8 + 4)\n    store<u8>(newString, CharCode.o, 8 + 5)\n    store<u8>(newString, CharCode.w, 8 + 6)\n    store<u8>(newString, CharCode.n, 8 + 7)\n    store<u8>(newString, CharCode.SPACE, 8 + 8)\n    store<u8>(newString, CharCode.v, 8 + 9)\n    store<u8>(newString, CharCode.a, 8 + 10)\n    store<u8>(newString, CharCode.l, 8 + 11)\n    store<u8>(newString, CharCode.u, 8 + 12)\n    store<u8>(newString, CharCode.e, 8 + 13)\n    store<u8>(newString, CharCode.RANGLE, 8 + 14)\n    UNKNOWN_VALUE_STRING = newString | GRAIN_GENERIC_HEAP_TAG_TYPE\n    incRef(UNKNOWN_VALUE_STRING) // <- avoid value getting GC'd\n  }\n  return UNKNOWN_VALUE_STRING\n}\n\n\nfunction grainHeapValueToString(ptr: u32, extraIndents: u32, toplevel: bool): u32 {\n  // ptr can be tagged or untagged\n  const untaggedPtr = ptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  const tag = load<u32>(untaggedPtr)\n  switch (tag) {\n    case GRAIN_STRING_HEAP_TAG: {\n      if (toplevel) {\n        return ptr\n      }\n      return quoteString(untaggedPtr)\n    }\n    case GRAIN_CHAR_HEAP_TAG: {\n      let byte = load<u8>(untaggedPtr + 4)\n      let numBytes: u32 = 0\n      if ((byte & 0x80) === 0x00) {\n        numBytes = 1\n      } else if ((byte & 0xF0) === 0xF0) {\n        numBytes = 4\n      } else if ((byte & 0xE0) === 0xE0) {\n        numBytes = 3\n      } else {\n        numBytes = 2\n      }\n      let str: u32\n      if (toplevel) {\n        str = allocateString(numBytes)\n        memory.copy(str + 8, untaggedPtr + 4, numBytes)\n      } else {\n        str = allocateString(numBytes + 2)\n        store<u8>(str + 8, <u8>(0x27))\n        memory.copy(str + 9, untaggedPtr + 4, numBytes)\n        store<u8>(str + 9 + numBytes, <u8>(0x27))\n      }\n      return str | GRAIN_GENERIC_HEAP_TAG_TYPE;\n    }\n    case GRAIN_ADT_HEAP_TAG: {\n      // [ <value type tag>, <module_tag>, <type_tag>, <variant_tag>, <arity>, elts ... ]\n      // these are tagged ints\n      let moduleId = load<i32>(untaggedPtr, 4 * 1) >> 1\n      let typeId = load<i32>(untaggedPtr, 4 * 2) >> 1\n      let variantId = load<i32>(untaggedPtr, 4 * 3) >> 1\n      // probably a linking issue!\n      if (!variantExists(moduleId, typeId, variantId)) return getAdtValueString()\n      let variantName: u32 = getVariantName(moduleId, typeId, variantId)\n      // Check if this is a list\n      // (hack to get list printing correct)\n      let listVariant = getListVariantString()\n      let isList = equal(variantName, listVariant) == GRAIN_TRUE\n      if (isList) return grainListToString(untaggedPtr, extraIndents)\n      let variantArity = getVariantArity(moduleId, typeId, variantId)\n      if (variantArity == 0) return variantName\n      // [NOTE] do not decRef variantName!\n      let ret = rightLiteralConcat1(variantName, CharCode.LPAREN)\n      for (let i = 0; i < variantArity; ++i) {\n        if (i > 0) {\n          let oldRet = ret\n          ret = rightLiteralConcat2(ret, CharCode.COMMA, CharCode.SPACE)\n          decRef(oldRet)\n        }\n        let oldRet = ret\n        let tmp = grainToStringHelp(load<u32>(untaggedPtr + 4 * (5 + i)), extraIndents, false)\n        ret = concat(ret, tmp)\n        decRef(tmp)\n        decRef(oldRet)\n      }\n      return rightLiteralConcat1(ret, CharCode.RPAREN)\n    }\n    case GRAIN_RECORD_HEAP_TAG: {\n      // these are tagged ints\n      let moduleId = load<i32>(untaggedPtr, 4 * 1) >> 1\n      let typeId = load<i32>(untaggedPtr, 4 * 2) >> 1\n      // probably a linking issue!\n      if (!recordTypeExists(moduleId, typeId)) return getRecordValueString()\n      let recordArity = getRecordArity(moduleId, typeId)\n      if (recordArity == 0) return getRecordValueString()\n      let lastSpacePadding = allocateString(0) | GRAIN_GENERIC_HEAP_TAG_TYPE\n      let spacePadding = twoByteString(CharCode.SPACE, CharCode.SPACE)\n      for (let i: u32 = 0; i < extraIndents; ++i) {\n        decRef(lastSpacePadding)\n        lastSpacePadding = spacePadding\n        spacePadding = rightLiteralConcat2(spacePadding, CharCode.SPACE, CharCode.SPACE)\n      }\n      let ret = leftLiteralConcat2(CharCode.LBRACE, CharCode.NEWLINE, spacePadding)\n      for (let i = 0; i < recordArity; ++i) {\n        if (i > 0) {\n          let oldRet = ret\n          ret = rightLiteralConcat2(ret, CharCode.COMMA, CharCode.NEWLINE)\n          decRef(oldRet)\n          oldRet = ret\n          ret = concat(ret, spacePadding)\n          decRef(oldRet)\n        }\n        // [NOTE] do not decRef:\n        let fieldName = getRecordFieldName(moduleId, typeId, i)\n        // [NOTE] *do* decRef\n        let fieldValue = grainToStringHelp(load<u32>(untaggedPtr + 4 * (4 + i)), extraIndents + 1, false)\n        // [TODO] refactor to copy less here\n        let oldRet = ret\n        ret = concat(ret, fieldName)\n        decRef(oldRet)\n        oldRet = ret\n        ret = rightLiteralConcat2(ret, CharCode.COLON, CharCode.SPACE)\n        decRef(oldRet)\n        oldRet = ret\n        ret = concat(ret, fieldValue)\n        decRef(oldRet)\n        decRef(fieldValue)\n      }\n      decRef(spacePadding)\n      let oldRet = ret\n      ret = rightLiteralConcat1(ret, CharCode.NEWLINE)\n      decRef(oldRet)\n      oldRet = ret\n      ret = concat(ret, lastSpacePadding)\n      decRef(oldRet)\n      oldRet = ret\n      ret = rightLiteralConcat1(ret, CharCode.RBRACE)\n      decRef(oldRet)\n      decRef(lastSpacePadding)\n      return ret\n    }\n    case GRAIN_ARRAY_HEAP_TAG: {\n      let ret = allocateString(3)\n      store<u8>(ret, CharCode.LBRACK, 8)\n      store<u8>(ret, CharCode.RANGLE, 8 + 1)\n      store<u8>(ret, CharCode.SPACE, 8 + 2)\n      ret = ret | GRAIN_GENERIC_HEAP_TAG_TYPE\n      let arity = load<i32>(untaggedPtr, 4 * 1)\n      for (let i = 0; i < arity; ++i) {\n        if (i > 0) {\n          let oldRet = ret\n          ret = rightLiteralConcat2(ret, CharCode.COMMA, CharCode.SPACE)\n          decRef(oldRet)\n        }\n        let oldRet = ret\n        let tmp = grainToStringHelp(load<u32>(untaggedPtr + 4 * (2 + i)), extraIndents, false)\n        ret = concat(ret, tmp)\n        decRef(tmp)\n        decRef(oldRet)\n      }\n      let oldRet = ret\n      ret = rightLiteralConcat1(ret, CharCode.RBRACK)\n      decRef(oldRet)\n      return ret\n    }\n    case GRAIN_BOXED_NUM_HEAP_TAG: {\n      let numberTag = load<u32>(untaggedPtr, 4 * 1)\n      switch (numberTag) {\n        case GRAIN_INT32_BOXED_NUM_TAG: {\n          return itoa32(loadInt32(untaggedPtr), 10)\n        }\n        case GRAIN_INT64_BOXED_NUM_TAG: {\n          return itoa64(loadInt64(untaggedPtr), 10)\n        }\n        case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n          let numerator = loadRationalNumerator(untaggedPtr)\n          let denominator = loadRationalDenominator(untaggedPtr)\n          let ret = itoa32(numerator, 10)\n          let oldRet = ret\n          ret = rightLiteralConcat1(ret, CharCode.SLASH)\n          decRef(oldRet)\n          oldRet = ret\n          let tmp = itoa32(denominator, 10)\n          ret = concat(ret, tmp)\n          decRef(tmp)\n          decRef(oldRet)\n          return ret\n        }\n        case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n          return dtoa(loadFloat32(untaggedPtr))\n        }\n        case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n          return dtoa(loadFloat64(untaggedPtr))\n        }\n      }\n    }\n    default: {\n      let tmp = itoa32(tag, 16)\n      let tmp2Rhs = allocateString(12)\n      store<u8>(tmp2Rhs, CharCode.SPACE, 8)\n      store<u8>(tmp2Rhs, CharCode.PIPE, 8 + 1)\n      store<u8>(tmp2Rhs, CharCode.SPACE, 8 + 2)\n      store<u8>(tmp2Rhs, CharCode.v, 8 + 3)\n      store<u8>(tmp2Rhs, CharCode.a, 8 + 4)\n      store<u8>(tmp2Rhs, CharCode.l, 8 + 5)\n      store<u8>(tmp2Rhs, CharCode.u, 8 + 6)\n      store<u8>(tmp2Rhs, CharCode.e, 8 + 7)\n      store<u8>(tmp2Rhs, CharCode.COLON, 8 + 8)\n      store<u8>(tmp2Rhs, CharCode.SPACE, 8 + 9)\n      store<u8>(tmp2Rhs, CharCode._0, 8 + 10)\n      store<u8>(tmp2Rhs, CharCode.x, 8 + 11)\n      tmp2Rhs = tmp2Rhs | GRAIN_GENERIC_HEAP_TAG_TYPE\n      let tmp2 = concat(tmp, tmp2Rhs)\n      let tmp3 = itoa32(ptr, 16)\n      let tmp4 = concat(tmp2, tmp3)\n      let tmp5 = rightLiteralConcat1(tmp4, CharCode.RANGLE)\n      let retLhs = allocateString(26)\n      store<u8>(retLhs, CharCode.LANGLE, 8)\n      store<u8>(retLhs, CharCode.u, 8 + 1)\n      store<u8>(retLhs, CharCode.n, 8 + 2)\n      store<u8>(retLhs, CharCode.k, 8 + 4)\n      store<u8>(retLhs, CharCode.n, 8 + 3)\n      store<u8>(retLhs, CharCode.o, 8 + 5)\n      store<u8>(retLhs, CharCode.w, 8 + 6)\n      store<u8>(retLhs, CharCode.n, 8 + 7)\n      store<u8>(retLhs, CharCode.SPACE, 8 + 8)\n      store<u8>(retLhs, CharCode.h, 8 + 9)\n      store<u8>(retLhs, CharCode.e, 8 + 10)\n      store<u8>(retLhs, CharCode.a, 8 + 11)\n      store<u8>(retLhs, CharCode.p, 8 + 12)\n      store<u8>(retLhs, CharCode.SPACE, 8 + 13)\n      store<u8>(retLhs, CharCode.t, 8 + 14)\n      store<u8>(retLhs, CharCode.a, 8 + 15)\n      store<u8>(retLhs, CharCode.g, 8 + 16)\n      store<u8>(retLhs, CharCode.SPACE, 8 + 17)\n      store<u8>(retLhs, CharCode.t, 8 + 18)\n      store<u8>(retLhs, CharCode.y, 8 + 19)\n      store<u8>(retLhs, CharCode.p, 8 + 20)\n      store<u8>(retLhs, CharCode.e, 8 + 21)\n      store<u8>(retLhs, CharCode.COLON, 8 + 22)\n      store<u8>(retLhs, CharCode.SPACE, 8 + 23)\n      store<u8>(retLhs, CharCode._0, 8 + 24)\n      store<u8>(retLhs, CharCode.x, 8 + 25)\n      retLhs = retLhs | GRAIN_GENERIC_HEAP_TAG_TYPE\n      let ret = concat(retLhs, tmp5)\n      decRef(tmp5)\n      decRef(tmp4)\n      decRef(tmp3)\n      decRef(tmp2)\n      decRef(tmp2Rhs)\n      decRef(tmp)\n      decRef(retLhs)\n      return ret\n    }\n  }\n}\n\nfunction grainToStringHelp(grainValue: u32, extraIndents: u32, toplevel: bool): u32 {\n  if (!(grainValue & 1)) {\n    // Simple (unboxed) numbers\n    return itoa32(<i32>(grainValue) >> 1, 10)\n  } else if ((grainValue & 7) == GRAIN_TUPLE_TAG_TYPE) {\n    let ptr = grainValue ^ 1\n    let tupleLength = load<u32>(ptr)\n    if (tupleLength & 0x80000000) {\n      return getCyclicTupleString() // ${grainValue & 0x7FFFFFFF}\n    } else {\n      store<u32>(ptr, 0x80000000 | tupleLength)\n      let ret = singleByteString(CharCode.LPAREN)\n      for (let i: u32 = 0; i < tupleLength; ++i) {\n        if (i > 0) {\n          let oldRet = ret\n          ret = rightLiteralConcat2(ret, CharCode.COMMA, CharCode.SPACE)\n          decRef(oldRet)\n        }\n        let oldRet = ret\n        let tmp = grainToStringHelp(load<u32>(ptr + ((i + 1) * 4)), extraIndents, false)\n        ret = concat(ret, tmp)\n        decRef(oldRet)\n        decRef(tmp)\n      }\n      store<u32>(ptr, tupleLength)\n      if (tupleLength <= 1) {\n        // Special case: unary tuple\n        let oldRet = ret\n        ret = rightLiteralConcat1(ret, CharCode.COMMA)\n        decRef(oldRet)\n      }\n      let oldRet = ret\n      ret = rightLiteralConcat1(ret, CharCode.RPAREN)\n      decRef(oldRet)\n      return ret\n    }\n  } else if ((grainValue & 7) == GRAIN_LAMBDA_TAG_TYPE) {\n    return getLambdaString()\n  } else if ((grainValue & 7) == GRAIN_GENERIC_HEAP_TAG_TYPE) {\n    return grainHeapValueToString(grainValue, extraIndents, toplevel)\n  } else if (grainValue == GRAIN_TRUE) {\n    return getTrueString()\n  } else if (grainValue == GRAIN_FALSE) {\n    return getFalseString()\n  } else if (grainValue == GRAIN_VOID) {\n    return getVoidString()\n  } else {\n    return getUnknownValueString()\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function grainToString(grainValue: u32): u32 {\n  return grainToStringHelp(grainValue, 0, true)\n}\n","import { log } from '../ascutils/console'\nimport { GRAIN_VOID } from '../ascutils/primitives'\nimport { grainToString } from './string'\n\nexport function print(grainValue: u32): u32 {\n  log(grainToString(grainValue))\n  return GRAIN_VOID\n}\n","import { malloc } from './grainRuntime'\n\nimport {\n  GRAIN_ARRAY_HEAP_TAG,\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n} from './tags'\n\n/**\n * Allocates a new Grain array.\n *\n * @param {u32} numElts The number of elements to be contained in this array\n * @returns {u32} The (untagged) pointer to the array\n */\nexport function allocateArray(numElts: u32): u32 {\n  let arr = malloc((numElts + 2) * 4)\n\n  store<u32>(arr, GRAIN_ARRAY_HEAP_TAG)\n  store<u32>(arr, numElts, 4)\n\n  return arr\n}\n\n/**\n * Stores an item in a Grain array.\n *\n * @param {u32} array The (untagged) array to store the item in\n * @param {u32} idx The index to store the item\n * @param {u32} item The item to store\n */\n@inline\nexport function storeInArray(arr: u32, idx: u32, item: u32): void {\n  store<u32>(arr + idx * 4, item, 8)\n}\n\n/**\n * Allocates a new Grain tuple.\n *\n * @param {u32} numElts The number of elements to be contained in this tuple\n * @returns {u32} The (untagged) pointer to the tuple\n */\nexport function allocateTuple(numElts: u32): u32 {\n  let tuple = malloc((numElts + 1) * 4)\n\n  store<u32>(tuple, numElts)\n\n  return tuple\n}\n\n/**\n * Allocates a new Grain string.\n *\n * @param {u32} size The size (in bytes) of the string to allocate\n * @returns {u32} The (untagged) pointer to the string\n */\nexport function allocateString(size: u32): u32 {\n  let str = malloc(size + 8)\n\n  store<u32>(str, GRAIN_STRING_HEAP_TAG)\n  store<u32>(str, size, 4)\n\n  return str\n}\n\n/**\n * Allocates a new Grain char.\n *\n * @returns {u32} The (untagged) pointer to the char\n */\nexport function allocateChar(): u32 {\n  let char = malloc(8)\n\n  store<u32>(char, GRAIN_CHAR_HEAP_TAG)\n\n  return char\n}\n\nexport function singleByteString(char: u8): u32 {\n  let s = allocateString(1)\n  store<u8>(s, char, 8)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function twoByteString(char1: u8, char2: u8): u32 {\n  let s = allocateString(2)\n  store<u8>(s, char1, 8)\n  store<u8>(s, char2, 8 + 1)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// [TODO] should probably migrate over the accessors in numbers.ts\n// INT32/INT64\n\n/**\n * Allocates a new Int64.\n *\n * @returns {u32}\n */\nexport function allocateInt64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int64 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt64(value: i64): u32 {\n  let ptr = allocateInt64()\n  store<i64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int64\n * @param wrappedInt64 The boxed int64 to return\n */\nexport function rawInt64Ptr(wrappedInt64: u32): u32 {\n  return wrappedInt64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64Unsigned(xptr: u32): u64 {\n  return load<u64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Int32.\n *\n * @returns {u32}\n */\nexport function allocateInt32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int32 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt32(value: i32): u32 {\n  let ptr = allocateInt32()\n  store<i32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int32\n * @param wrappedInt32 The boxed int32 to return\n */\nexport function rawInt32Ptr(wrappedInt32: u32): u32 {\n  return wrappedInt32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32Unsigned(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// FLOATS\n\n/**\n * Allocates a new Float32.\n *\n * @returns {u32}\n */\nexport function allocateFloat32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float32 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat32(value: f32): u32 {\n  let ptr = allocateFloat32()\n  store<f32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float32\n * @param wrappedFloat32 The boxed float32 to return\n */\nexport function rawFloat32Ptr(wrappedFloat32: u32): u32 {\n  return wrappedFloat32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat32(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Float64.\n *\n * @returns {u32}\n */\nexport function allocateFloat64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float64 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat64(value: f64): u32 {\n  let ptr = allocateFloat64()\n  store<f64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float64\n * @param wrappedFloat64 The boxed float64 to return\n */\nexport function rawFloat64Ptr(wrappedFloat64: u32): u32 {\n  return wrappedFloat64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat64(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// RATIONALS\n\n/**\n * Allocates a new Rational.\n *\n * @returns {u32}\n */\nexport function allocateRational(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_RATIONAL_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Rational with a prepopulated value\n * @param value The value to store\n */\nexport function newRational(numerator: i32, denominator: i32): u32 {\n  let ptr = allocateRational()\n  store<i32>(ptr + 8, numerator)\n  store<i32>(ptr + 12, denominator)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalNumeratorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 8\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalDenominatorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 12\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n/**\n * Load a value from an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @param {u32} idx Index (from zero) of the item\n * @returns {u32} The value located at the index\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVal(ptr: u32, idx: u32): u32 {\n  return load<u32>(ptr + (idx * 4), 5 * 4)\n}\n\n/**\n * Load the (tagged) variant of an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @returns {u32} The (tagged) ADT variant id\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVariant(ptr: u32): u32 {\n  return load<u32>(ptr, 3 * 4)\n}\n\n/**\n * Load an untagged string's size.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the string\n * @returns {u32} The (untagged) string size (in bytes)\n */\n// @ts-ignore: decorator\n@inline\nexport function stringSize(ptr: u32): u32 {\n  return load<u32>(ptr, 4)\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: usize = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_dec_core(out, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: usize = 0;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_dec_core(out, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_hex_core(out, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, val32, decimals, radix);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: usize = 0;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = __alloc(decimals << 1, idof<String>());\n      utoa32_dec_core(out, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = __alloc(decimals << 1, idof<String>());\n      utoa64_dec_core(out, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: usize = 0;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = __alloc(decimals << 1, idof<String>());\n      utoa32_dec_core(out, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = __alloc(decimals << 1, idof<String>());\n      utoa64_dec_core(out, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_hex_core(out, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_any_core(out, value, decimals, radix);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10)); // retains\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10)); // retains\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10)); // retains\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10)); // retains\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    ); // retains\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = __alloc((estLen + sepLen * lastIndex) << 1, idof<string>());\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        result + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      result + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return changetype<string>(result); // retains\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<String>(out); // retains\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = __alloc(<usize>length << 1, idof<String>());\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(out + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return changetype<String>(out);\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<String>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(out, lo | (hi << 16));\n    }\n    return changetype<String>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (intStart << 1), size);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, size);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<Array<String>>(__allocArray(<i32>length, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<Array<String>>(__allocArray(1, alignof<String>(), idof<Array<String>>())); // retains\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 2 * 2, idof<String>());\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(codes + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(codes + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(codes + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(codes + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(codes + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = __alloc(len * 3 * 2, idof<String>());\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(codes + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(codes + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(codes + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(codes + (j << 1), ab, 0);\n            store<u16>(codes + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(codes + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(codes + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    codes = __realloc(codes, j << 1);\n    return changetype<String>(codes); // retains\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var buf = __alloc(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>());\n      encodeUnsafe(changetype<usize>(str), str.length, buf, nullTerminated);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && str + 2 < strEnd) {\n            let c2 = <u32>load<u16>(str, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; str += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<String>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = __alloc(<usize>byteLength(str), idof<ArrayBuffer>());\n      encodeUnsafe(changetype<usize>(str), str.length, buf);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = __alloc(len &= ~1, idof<String>());\n      memory.copy(str, buf, len);\n      return changetype<String>(str); // retains\n    }\n  }\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n - 4;\n    store<u8>(dest, c);\n    store<u8>(dend, c, 3);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend, c, 2);\n    store<u8>(dend, c, 1);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n - 28;\n    store<u32>(dest, c32);\n    store<u32>(dend, c32, 24);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend, c32, 16);\n    store<u32>(dend, c32, 20);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend, c32);\n    store<u32>(dend, c32, 4);\n    store<u32>(dend, c32, 8);\n    store<u32>(dend, c32, 12);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import {\n  GRAIN_NUMBER_TAG_TYPE,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n\n  GRAIN_NUMBER_TAG_MASK,\n  GRAIN_GENERIC_TAG_MASK,\n\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n} from './ascutils/tags'\n\nimport {\n  GRAIN_ERR_OVERFLOW,\n  GRAIN_ERR_DIVISION_BY_ZERO,\n  GRAIN_ERR_NOT_INTLIKE,\n  GRAIN_ERR_NOT_RATIONAL,\n  GRAIN_ERR_MODULO_BY_ZERO,\n} from './ascutils/errors'\n\nimport {\n  GRAIN_TRUE,\n  GRAIN_FALSE,\n} from './ascutils/primitives'\n\nimport { throwError } from './ascutils/grainRuntime'\n\nimport {\n  newRational,\n  newInt32,\n  newInt64,\n  newFloat32,\n  newFloat64\n} from './ascutils/dataStructures'\n\nexport {\n  newRational,\n  newInt32,\n  newInt64,\n  newFloat32,\n  newFloat64\n}\n\n// [TODO] (#301) pretty much all of the overflow values we pass here are suboptimal...really need to rework this\n// @ts-ignore: decorator\n@inline\nfunction throwOverflowError(x: u32): u32 {\n  return throwError(GRAIN_ERR_OVERFLOW, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwDivideByZero(): u32 {\n  return throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwNotIntLike(x: u32): u32 {\n  return throwError(GRAIN_ERR_NOT_INTLIKE, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwNotRational(x: u32): u32 {\n  return throwError(GRAIN_ERR_NOT_RATIONAL, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction encodeBool(b: bool): u32 {\n  return b ? GRAIN_TRUE : GRAIN_FALSE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction tagSimple(x: i32): u32 {\n  return x << 1\n}\n\n// @ts-ignore: decorator\n@inline\nfunction untagSimple(x: u32): i32 {\n  return <i32>(x) >> 1\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI64toI32(x: i64): i32 {\n  if (x > I32.MAX_VALUE || x < I32.MIN_VALUE) {\n    return throwOverflowError(<u32>(x))\n  } else {\n    return <i32>(x)\n  }\n}\n\n// https://en.wikipedia.org/wiki/Binary_GCD_algorithm\nfunction gcdHelp(x: i64, y: i64): i64 {\n  if (x == y) {\n    return y\n  }\n  if (x == 0) {\n    return y\n  }\n  if (y == 0) {\n    return x\n  }\n  if ((~x & 1) != 0) {\n    // x is even\n    if ((y & 1) != 0) {\n      // y is odd\n      return gcdHelp(x >> 1, y)\n    } else {\n      return gcdHelp(x >> 1, y >> 1) << 1\n    }\n  }\n  if ((~y & 1) != 0) {\n    // y is even and x is odd\n    return gcdHelp(x, y >> 1)\n  }\n  if (x > y) {\n    return gcdHelp(x - y, y)\n  }\n  return gcdHelp(y - x, x)\n}\n\nfunction gcd(x: i64, y: i64): i64 {\n  // Algorithm above breaks on negatives, so\n  // we make sure that they are positive at the beginning\n  return gcdHelp(abs<i64>(x), abs<i64>(y))\n}\n\nfunction gcd32(x: i32, y: i32): i32 {\n  return <i32>(gcd(<i64>(x), <i64>(y)))\n}\n\n\nfunction reducedFraction(x: i32, y: i32): u32 {\n  if (y < 0) {\n    // Normalization 1: Never do negative/negative\n    // Normalization 2: Never allow a negative denominator\n    x = -x\n    y = -y\n  }\n  if (y == 0) {\n    return throwDivideByZero()\n  }\n  if (x % y == 0) {\n    // Avoid allocation if possible\n    return reducedInteger(<i64>(x) / <i64>(y))\n  }\n  // x not evenly divisible by y\n  let factor = gcd32(x, y)\n  return newRational(x / factor, y / factor)\n}\n\nfunction reducedFraction64(x: i64, y: i64): u32 {\n  if (y < 0) {\n    // Normalization 1: Never do negative/negative\n    // Normalization 2: Never allow a negative denominator\n    x = -x\n    y = -y\n  }\n  if (y == 0) {\n    return throwDivideByZero()\n  }\n  if (x % y == 0) {\n    return reducedInteger(x / y)\n  }\n  let factor = gcd(x, y)\n  let xdiv = safeI64toI32(x / factor)\n  let ydiv = safeI64toI32(y / factor)\n  return newRational(xdiv, ydiv)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction reducedInteger(x: i64): u32 {\n  if ((x > I32.MAX_VALUE) || (x < I32.MIN_VALUE)) {\n    return newInt64(x)\n  } else if ((x > (I32.MAX_VALUE >> 1)) || (x < (I32.MIN_VALUE >> 1))) {\n    return newInt32(<i32>(x))\n  } else {\n    return tagSimple(<i32>(x))\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI32Multiply(x: i32, y: i32): i32 {\n  let prod = <i64>(x) * <i64>(y)\n  if (prod > I32.MAX_VALUE || prod < I32.MIN_VALUE) {\n    return throwOverflowError(<u32>(x))\n  }\n  return <i32>(prod);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI64Multiply(x: i64, y: i64): i64 {\n  let prod = x * y\n  if (x != 0 && prod / x != y) {\n    // [TODO] (#301) just passing x is kind of bad UX\n    // [TODO] (#302) once we have exception handling, this will leak\n    return throwOverflowError(newInt64(x))\n  }\n  return prod;\n}\n\n// Accessor functions\n\n/* Memory Layout:\n * [GRAIN_BOXED_NUM_HEAP_TAG : u32, <boxed_num tag> : u32, <number-specific payload>...]\n * (payload depends on boxed_num tag...see below)\n *\n * Payloads:\n * For Int32:\n * [number: i32]\n *\n * For Int64:\n * [number: i64]\n *\n * For Float32:\n * [number: f32]\n *\n * For Float64:\n * [number: f64]\n *\n * For Rational:\n * [numerator: i32, denominator: u32]\n */\n\n// @ts-ignore: decorator\n@inline\nexport function boxedNumberTag(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 1 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedInt32Number(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedInt64Number(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedFloat32Number(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedFloat64Number(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n\nfunction coerceFloat32(x: u32): f32 {\n  if (isSimpleNumber(x)) {\n    return <f32>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <f32>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return <f32>(boxedInt64Number(x))\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return <f32>(boxedRationalNumerator(x)) / <f32>(boxedRationalDenominator(x))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return boxedFloat32Number(x)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let xval = boxedFloat64Number(x)\n      if (xval > F32.MAX_VALUE || xval < F32.MIN_VALUE) {\n        // Not an actual return value\n        throwOverflowError(x)\n        return unreachable()\n      } else {\n        return <f32>(xval)\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction coerceFloat64(x: u32): f64 {\n  if (isSimpleNumber(x)) {\n    return <f64>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <f64>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return <f64>(boxedInt64Number(x))\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return <f64>(boxedRationalNumerator(x)) / <f64>(boxedRationalDenominator(x))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return <f64>(boxedFloat32Number(x))\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return boxedFloat64Number(x)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction coerceInt64(x: u32): i64 {\n  if (isSimpleNumber(x)) {\n    return <i64>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <i64>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return boxedInt64Number(x)\n    } default: {\n      // rationals are never integral, and we refuse to coerce floats to ints\n      return throwNotIntLike(x)\n    }\n  }\n}\n\nfunction coerceInt32(x: u32): i32 {\n  let asInt64 = coerceInt64(x)\n  if (asInt64 > <i64>(I32.MAX_VALUE) || asInt64 < <i64>(I32.MIN_VALUE)) {\n    return throwOverflowError(x)\n  }\n  return <i32>(asInt64)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction isSimpleNumber(x: u32): bool {\n  return (x & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction isBoxedNumber(x: u32): bool {\n  return ((x & GRAIN_GENERIC_TAG_MASK) == GRAIN_GENERIC_HEAP_TAG_TYPE) &&\n    ((load<u32>(x ^ GRAIN_GENERIC_HEAP_TAG_TYPE) == GRAIN_BOXED_NUM_HEAP_TAG))\n}\n\n// @ts-ignore: decorator\n@inline\nfunction boxedNumberPtr(x: u32): u32 {\n  return x ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isNumber(x: u32): bool {\n  // x is a number if it is a literal number or a boxed_num heap value\n  return isSimpleNumber(x) || isBoxedNumber(x)\n}\n\n/** Number-aware equality checking\n  * The basic idea is that we first figure out the type of the\n  * number on the LHS, and then figure out if the RHS number is equal\n  * to that number\n  *\n  * NOTE: The preconditions in these functions are important, so do NOT\n  *       export them!\n  */\n\nfunction numberEqualSimpleHelp(x: u32, yTagged: u32): bool {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and x !== y and isNumber(y)\n  if (isSimpleNumber(yTagged)) {\n    // x !== y, so they must be different\n    return false\n  }\n  let xval = untagSimple(x) // <- actual int value of x\n  let y = boxedNumberPtr(yTagged)\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return <i32>(xval) == yBoxedVal\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return <i64>(xval) == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      return false\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      return F32.isSafeInteger(yBoxedVal) && <i64>(xval) == <i64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      return F64.isSafeInteger(yBoxedVal) && <i64>(xval) == <i64>(yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n\nfunction numberEqualInt64Help(xBoxedVal: i64, y: u32): bool {\n  // PRECONDITION: x !== y and isNumber(y)\n  // Basic number:\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return xBoxedVal == <i64>(untagSimple(y))\n  }\n  // Boxed number:\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return xBoxedVal == <i64>(yBoxedVal)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return xBoxedVal == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      return false\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      return F32.isSafeInteger(yBoxedVal) && xBoxedVal == <i64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      return F64.isSafeInteger(yBoxedVal) && xBoxedVal == <i64>(yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualInt32Help(xBoxedVal: i32, y: u32): bool {\n  // We can just pretend it's 64-bit for the equality check\n  return numberEqualInt64Help(<i64>(xBoxedVal), y)\n}\n\nfunction numberEqualRationalHelp(xptr: u32, y: u32): bool {\n  // PRECONDITION: x is rational and x !== y and isNumber(y)\n  // Basic number: (we know it's not equal, since we never store ints as rationals)\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return false\n  }\n  let xNumerator = boxedRationalNumerator(xptr)\n  let xDenominator = boxedRationalDenominator(xptr)\n  // Boxed number:\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return false\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return false\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      return (xNumerator == yNumerator) && (xDenominator == yDenominator)\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      let xAsFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return xAsFloat == yBoxedVal\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      let xAsFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return xAsFloat == yBoxedVal\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualFloat64Help(x: f64, y: u32): bool {\n  let xIsInteger = F64.isInteger(x)\n  // Basic number:\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return xIsInteger && x == <f64>(untagSimple(y))\n  }\n  // Boxed number\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return F64.isSafeInteger(x) && <i64>(x) == <i64>(yBoxedVal)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return F64.isSafeInteger(x) && <i64>(x) == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      let yAsFloat = <f64>(yNumerator) / <f64>(yDenominator)\n      return x == yAsFloat\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return x == <f64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return x == yBoxedVal\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualFloat32Help(x: f32, y: u32): bool {\n  return numberEqualFloat64Help(<f64>(x), y)\n}\n\nexport function numberEqual(x: u32, y: u32): bool {\n  // Short circuit if value/pointer is the same\n  if (x === y) return true\n  if (!isNumber(x)) return false\n  if (!isNumber(y)) return false\n  if (isSimpleNumber(x)) {\n    return numberEqualSimpleHelp(x, y)\n  }\n  // Boxed number\n  let xBoxedNumberTag = boxedNumberTag(x)\n  switch (xBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let xBoxedVal = boxedInt32Number(x)\n      return numberEqualInt32Help(xBoxedVal, y)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let xBoxedVal = boxedInt64Number(x)\n      return numberEqualInt64Help(xBoxedVal, y)\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberEqualRationalHelp(x, y)\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberEqualFloat32Help(boxedFloat32Number(x), y)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberEqualFloat64Help(boxedFloat64Number(x), y)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n/*\n * ===== PLUS & MINUS =====\n * (same schema as equal())\n */\n\nfunction numberPlusMinusSimpleHelp(x: u32, y: u32, isMinus: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    return reducedInteger(<i64>(untagSimple(x)) + <i64>(untagSimple(y) * (isMinus ? -1 : 1)))\n  }\n  let xval = untagSimple(x) // <- actual int value of x\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y) * (isMinus ? -1 : 1)\n      return reducedInteger(<i64>(xval) + <i64>(yBoxedVal))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y) * (isMinus ? -1 : 1)\n      let xval64 = <i64>(xval)\n      let sum = xval64 + yBoxedVal\n      if (yBoxedVal >= 0 && sum < xval64) {\n        return throwOverflowError(y)\n      } else if (yBoxedVal < 0 && sum > xval64) {\n        return throwOverflowError(y)\n      } else {\n        return reducedInteger(sum)\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      let expandedXNumerator = safeI64Multiply(<i64>(xval), yDenominator)\n      let sum = <i64>(expandedXNumerator) + <i64>(yNumerator)\n      if (sum < I32.MIN_VALUE || sum > I32.MAX_VALUE) {\n        return throwOverflowError(y)\n      }\n      return reducedFraction64(sum, <i64>(yDenominator))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y) * (isMinus ? -1.0 : 1.0)\n      // [TODO] (#304) is this safe?\n      return newFloat32(<f32>(xval) + yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n      return newFloat64(<f64>(xval) + yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberPlusMinusInt64Help(xval: i64, y: u32, isMinus: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    let yval = <i64>(untagSimple(y) * (isMinus ? -1 : 1))\n    let sum = xval + yval\n    if (yval >= 0 && sum < xval) {\n      return throwOverflowError(y)\n    } else if (yval < 0 && sum > xval) {\n      return throwOverflowError(y)\n    }\n    return reducedInteger(sum)\n  }\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y) * (isMinus ? -1 : 1)\n      return reducedInteger(xval + <i64>(yBoxedVal))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y) * (isMinus ? -1 : 1)\n      let xval64 = xval\n      let sum = xval64 + yBoxedVal\n      if (yBoxedVal >= 0 && sum < xval64) {\n        return throwOverflowError(y)\n      } else if (yBoxedVal < 0 && sum > xval64) {\n        return throwOverflowError(y)\n      } else {\n        return reducedInteger(sum)\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      let expandedXNumerator = safeI64Multiply(xval, yDenominator)\n      let sum = expandedXNumerator + <i64>(yNumerator)\n      if (sum < I32.MIN_VALUE || sum > I32.MAX_VALUE) {\n        return throwOverflowError(y)\n      }\n      return reducedFraction64(sum, <i64>(yDenominator))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y) * (isMinus ? -1.0 : 1.0)\n      // [TODO] (#304) this isn't safe enough\n      return newFloat32(<f32>(xval) + yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n      return newFloat64(<f64>(xval) + yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberPlusMinusRationalHelp(x: u32, y: u32, isMinus: bool): u32 {\n  if (isSimpleNumber(y)) {\n    return numberPlusMinusSimpleHelp(y, x, isMinus)\n  }\n  let ytag = boxedNumberTag(y)\n  switch (ytag) {\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // The one case we don't delegate is rational +/- rational\n      let xNumerator = boxedRationalNumerator(x)\n      let xDenominator = boxedRationalDenominator(x)\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      // [TODO] {#304) this could be written in a more overflow-proof way\n      if (xDenominator == yDenominator) {\n        return reducedFraction64(<i64>(xNumerator) + <i64>(yNumerator), xDenominator)\n      }\n      let numerator1 = safeI64Multiply(xNumerator, yDenominator)\n      let numerator2 = safeI64Multiply(yNumerator, xDenominator)\n      let numerator = numerator1 + numerator2\n      let denominator = safeI64Multiply(xDenominator, yDenominator)\n      return reducedFraction64(numerator, denominator)\n    } case GRAIN_INT32_BOXED_NUM_TAG:\n    case GRAIN_INT64_BOXED_NUM_TAG:\n    case GRAIN_FLOAT32_BOXED_NUM_TAG:\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberPlusMinusHelp(y, x, isMinus)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n\nfunction numberPlusMinusFloat32Help(xval: f32, y: u32, isMinus: bool): u32 {\n  if (!isSimpleNumber(y) && boxedNumberTag(y) == GRAIN_FLOAT64_BOXED_NUM_TAG) {\n    // Special case: promote to f64 if RHS is f64\n    let yval = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n    return newFloat64(<f64>(xval) + yval)\n  } else {\n    let yval = coerceFloat32(y) * (isMinus ? -1.0 : 1.0)\n    return newFloat32(xval + yval)\n  }\n}\n\nfunction numberPlusMinusFloat64Help(xval: f64, y: u32, isMinus: bool): u32 {\n  let yval = coerceFloat64(y) * <f64>(isMinus ? -1.0 : 1.0)\n  return newFloat64(xval + yval)\n}\n\n\nfunction numberPlusMinusInt32Help(xval: i32, y: u32, isMinus: bool): u32 {\n  return numberPlusMinusInt64Help(<i64>(xval), y, isMinus)\n}\n\nfunction numberPlusMinusHelp(x: u32, y: u32, isMinus: bool): u32 {\n  if (isSimpleNumber(x)) {\n    return numberPlusMinusSimpleHelp(x, y, isMinus)\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return numberPlusMinusInt32Help(boxedInt32Number(x), y, isMinus)\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      return numberPlusMinusInt64Help(boxedInt64Number(x), y, isMinus)\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberPlusMinusRationalHelp(x, y, isMinus)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberPlusMinusFloat32Help(boxedFloat32Number(x), y, isMinus)\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberPlusMinusFloat64Help(boxedFloat64Number(x), y, isMinus)\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n\nexport function numberPlus(x: u32, y: u32): u32 {\n  return numberPlusMinusHelp(x, y, false)\n}\n\nexport function numberMinus(x: u32, y: u32): u32 {\n  return numberPlusMinusHelp(x, y, true)\n}\n\n/*\n * ===== TIMES & DIVIDE =====\n * (same schema as equal())\n */\n\nfunction numberTimesDivideSimpleHelp(x: u32, y: u32, isDivide: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  let xval = untagSimple(x) // <- actual int value of x\n  return numberTimesDivideInt64Help(<i64>(xval), y, isDivide)\n}\n\nfunction numberTimesDivideInt32Help(xval: i32, y: u32, isDivide: bool): u32 {\n  return numberTimesDivideInt64Help(<i64>(xval), y, isDivide)\n}\n\nfunction numberTimesDivideInt64Help(xval: i64, y: u32, isDivide: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    if (isDivide) {\n      return reducedFraction64(xval, <i64>(untagSimple(y)))\n    } else {\n      return reducedInteger(safeI64Multiply(xval, <i64>(untagSimple(y))))\n    }\n  }\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      if (isDivide) {\n        return reducedFraction64(xval, <i64>(yBoxedVal))\n      } else {\n        return reducedInteger(safeI64Multiply(xval, <i64>(yBoxedVal)))\n      }\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      if (isDivide) {\n        return reducedFraction64(xval, yBoxedVal)\n      } else {\n        return reducedInteger(safeI64Multiply(xval, yBoxedVal))\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      if (isDivide) {\n        // x / (a / b) == (x * b) / a\n        let numerator = safeI64Multiply(xval, yDenominator)\n        return reducedFraction64(numerator, yNumerator)\n      } else {\n        // x * (a / b) == (x * a) / b\n        let numerator = safeI64Multiply(xval, yNumerator)\n        return reducedFraction64(numerator, yDenominator)\n      }\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      // [TODO] (#304) is this safe?\n      if (isDivide) {\n        return newFloat32(<f32>(xval) / yBoxedVal)\n      } else {\n        return newFloat32(<f32>(xval) * yBoxedVal)\n      }\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      if (isDivide) {\n        return newFloat64(<f64>(xval) / yBoxedVal)\n      } else {\n        return newFloat64(<f64>(xval) * yBoxedVal)\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberTimesDivideRationalHelp(x: u32, y: u32, isDivide: bool): u32 {\n  // Division isn't commutative, so we actually need to do the work\n  let xNumerator = boxedRationalNumerator(x)\n  let xDenominator = boxedRationalDenominator(x)\n  if (isSimpleNumber(y)) {\n    if (isDivide) {\n      // (a / b) / y == a / (b * y)\n      let denominator = safeI64Multiply(xDenominator, <i64>(untagSimple(y)))\n      return reducedFraction64(xNumerator, denominator)\n    } else {\n      // (a / b) * y == (a * y) / b\n      let numerator = safeI64Multiply(xNumerator, <i64>(untagSimple(y)))\n      return reducedFraction64(numerator, xDenominator)\n    }\n  }\n  let ytag = boxedNumberTag(y)\n  switch (ytag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      // Same idea as above\n      if (isDivide) {\n        // (a / b) / y == a / (b * y)\n        let denominator = safeI64Multiply(xDenominator, <i64>(boxedInt32Number(y)))\n        return reducedFraction64(xNumerator, denominator)\n      } else {\n        // (a / b) * y == (a * y) / b\n        let numerator = safeI64Multiply(xNumerator, <i64>(boxedInt32Number(y)))\n        return reducedFraction64(numerator, xDenominator)\n      }\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      // Same idea as above\n      if (isDivide) {\n        // (a / b) / y == a / (b * y)\n        let denominator = safeI64Multiply(xDenominator, boxedInt64Number(y))\n        return reducedFraction64(xNumerator, denominator)\n      } else {\n        // (a / b) * y == (a * y) / b\n        let numerator = safeI64Multiply(xNumerator, boxedInt64Number(y))\n        return reducedFraction64(numerator, xDenominator)\n      }\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let xNumerator = boxedRationalNumerator(x)\n      let xDenominator = boxedRationalDenominator(x)\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      // (a / b) * (c / d) == (a * c) / (b * d)\n      // (a / b) / (c / d) == (a * d) / (b * c)\n      // [TODO] (#304) this could maybe be written in a more overflow-proof way\n      let numerator = isDivide ? safeI64Multiply(xNumerator, yDenominator) : safeI64Multiply(xNumerator, yNumerator)\n      let denominator = isDivide ? safeI64Multiply(xDenominator, yNumerator) : safeI64Multiply(xDenominator, yDenominator)\n      return reducedFraction64(numerator, denominator)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let asFloat = <f32>(xNumerator) / <f32>(xDenominator)\n      if (isDivide) {\n        return newFloat32(asFloat / boxedFloat32Number(y))\n      } else {\n        return newFloat32(asFloat * boxedFloat32Number(y))\n      }\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let asFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      if (isDivide) {\n        return newFloat64(asFloat / boxedFloat64Number(y))\n      } else {\n        return newFloat64(asFloat * boxedFloat64Number(y))\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberTimesDivideFloat64Help(x: f64, y: u32, isDivide: bool): u32 {\n  let yAsFloat = coerceFloat64(y)\n  if (isDivide) {\n    return newFloat64(x / yAsFloat)\n  } else {\n    return newFloat64(x * yAsFloat)\n  }\n}\n\nfunction numberTimesDivideFloat32Help(x: f32, y: u32, isDivide: bool): u32 {\n  if (isBoxedNumber(y) && boxedNumberTag(y) == GRAIN_INT64_BOXED_NUM_TAG) {\n    // Special case: f32->f64 promotion\n    if (isDivide) {\n      return newFloat64(<f64>(x) / boxedFloat64Number(y))\n    } else {\n      return newFloat64(<f64>(x) * boxedFloat64Number(y))\n    }\n  }\n  let yAsFloat = coerceFloat32(y)\n  if (isDivide) {\n    return newFloat32(x / yAsFloat)\n  } else {\n    return newFloat32(x * yAsFloat)\n  }\n}\n\nfunction numberTimesDivideHelp(x: u32, y: u32, isDivide: bool): u32 {\n  if (isSimpleNumber(x)) {\n    return numberTimesDivideSimpleHelp(x, y, isDivide)\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return numberTimesDivideInt32Help(boxedInt32Number(x), y, isDivide)\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      return numberTimesDivideInt64Help(boxedInt64Number(x), y, isDivide)\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberTimesDivideRationalHelp(x, y, isDivide)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberTimesDivideFloat32Help(boxedFloat32Number(x), y, isDivide)\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberTimesDivideFloat64Help(boxedFloat64Number(x), y, isDivide)\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n\nexport function numberTimes(x: u32, y: u32): u32 {\n  return numberTimesDivideHelp(x, y, false)\n}\n\nexport function numberDivide(x: u32, y: u32): u32 {\n  return numberTimesDivideHelp(x, y, true)\n}\n\n/*\n * ===== MODULO =====\n * (same schema as equal())\n */\n\nexport function numberMod(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  if (yval == 0) {\n    return throwError(GRAIN_ERR_MODULO_BY_ZERO, 0, 0)\n  }\n  // AssemblyScript's % is the remainder operator, so we implement modulo manually\n  if (xval < 0 && yval > 0 || xval > 0 && yval < 0) {\n    let modval = abs<i64>(xval) % abs<i64>(yval)\n    return reducedInteger(modval != 0 ? (abs<i64>(yval) - modval) * (yval < 0 ? -1 : 1) : modval)\n  } else {\n    return reducedInteger(xval % yval)\n  }\n}\n\n/*\n * ===== LESS THAN / GREATER THAN / LESS EQUAL / GREATER EQUAL =====\n * Coerce to float64 and then do comparisons\n * [TODO] (#305) Could probably be made more efficient\n */\n// [TODO] (#305) is this safe? I think it's safe?\nexport function numberLess(x: u32, y: u32): u32 {\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  return encodeBool(xval < yval)\n}\n\nexport function numberGreater(x: u32, y: u32): u32 {\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  return encodeBool(xval > yval)\n}\n\nexport function numberLessEqual(x: u32, y: u32): u32 {\n  // Equality is finicky, so delegate\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  if (xval < yval) {\n    return encodeBool(true)\n  } else {\n    return encodeBool(numberEqual(x, y))\n  }\n}\n\nexport function numberGreaterEqual(x: u32, y: u32): u32 {\n  // Equality is finicky, so delegate\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  if (xval > yval) {\n    return encodeBool(true)\n  } else {\n    return encodeBool(numberEqual(x, y))\n  }\n}\n\n/*\n * ===== EQUAL =====\n */\n\nexport function numberEq(x: u32, y: u32): u32 {\n  return encodeBool(numberEqual(x, y))\n}\n\n/*\n * ===== LOGICAL OPERATIONS =====\n * Only valid for int-like numbers. Coerce to i64 and do operations\n */\n// [TODO] (#306) Semantics around when things should stay i32/i64\n\nexport function numberLnot(x: u32): u32 {\n  let xval = coerceInt64(x)\n  return reducedInteger(~xval)\n}\n\nexport function numberLsl(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval << yval)\n}\n\nexport function numberLsr(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval >>> yval)\n}\n\nexport function numberLand(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval & yval)\n}\n\nexport function numberLor(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval | yval)\n}\n\nexport function numberLxor(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval ^ yval)\n}\n\nexport function numberAsr(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval >> yval)\n}\n\n// inc/dec\n\nexport function numberIncr(x: u32): u32 {\n  return numberPlus(x, tagSimple(1));\n}\n\nexport function numberDecr(x: u32): u32 {\n  return numberMinus(x, tagSimple(1));\n}\n\n\n/// USER-EXPOSED COERCION FUNCTIONS\n//\n// [NOTE]: Coercion is a *conservative* process! For example, even if a float is 1.0,\n//         we will fail if attempting to coerce to an int!\n\nexport function coerceNumberToInt32(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_INT32_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  // can possibly fail\n  return newInt32(coerceInt32(x))\n}\n\nexport function coerceNumberToInt64(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_INT64_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newInt64(coerceInt64(x))\n}\n\nexport function coerceNumberToRational(x: u32): u32 {\n  if (isSimpleNumber(x)) {\n    return newRational(x >> 1, 1)\n  }\n  let tag = boxedNumberTag(x)\n  if (tag == GRAIN_RATIONAL_BOXED_NUM_TAG) {\n    return x\n  }\n  if (tag == GRAIN_INT32_BOXED_NUM_TAG) {\n    return newRational(boxedInt32Number(x), 1)\n  }\n  if (tag == GRAIN_INT64_BOXED_NUM_TAG) {\n    return newRational(coerceInt32(x), 1)\n  }\n  return throwNotRational(x)\n}\n\nexport function coerceNumberToFloat32(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_FLOAT32_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newFloat32(coerceFloat32(x))\n}\n\nexport function coerceNumberToFloat64(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_FLOAT64_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newFloat64(coerceFloat64(x))\n}\n\nexport function coerceInt32ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceInt64ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceRationalToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceFloat32ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceFloat64ToNumber(x: u32): u32 {\n  return x\n}\n\n/// USER-EXPOSED CONVERSION FUNCTIONS\n\nexport function convertExactToInexact(x: u32): u32 {\n  return x\n}\n\nexport function convertInexactToExact(x: u32): u32 {\n  if (isSimpleNumber(x)) {\n    return x\n  }\n  let tag = boxedNumberTag(x)\n  if (tag == GRAIN_INT32_BOXED_NUM_TAG || tag == GRAIN_INT64_BOXED_NUM_TAG || tag == GRAIN_RATIONAL_BOXED_NUM_TAG) {\n    return x\n  }\n  switch (tag) {\n    case GRAIN_INT32_BOXED_NUM_TAG:\n    case GRAIN_INT64_BOXED_NUM_TAG:\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return x\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return reducedInteger(<i64>(<f32>(nearest(boxedFloat32Number(x)))))\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return reducedInteger(<i64>(<f64>(nearest(boxedFloat64Number(x)))))\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(this, radix);\n    } else {\n      return itoa64(this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return utoa32(this, radix);\n    } else {\n      return utoa64(this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\t\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma<T>(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms<T>(v1: v128, v2: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function widen_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i64x2_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfma(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function qfms(a: v128, b: v128, c: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v16x8 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v32x4 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\nexport namespace v64x2 {\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\ndeclare function seed(): f64;\n","import { fd_write } from 'bindings/wasi'\nimport { calloc, free } from './grainRuntime'\nimport { GRAIN_GENERIC_HEAP_TAG_TYPE } from './tags';\n\nexport declare function debug(value: u64): void\nexport declare function tracepoint(n: u32): void\n\n// Implementation of writeStringLn from as-wasi: https://github.com/jedisct1/as-wasi\n// (MIT License)\nexport function log(grainString: u32): void {\n  let ptr = grainString & ~GRAIN_GENERIC_HEAP_TAG_TYPE\n  let iov = calloc(32)\n  store<u32>(iov, ptr + 8)\n  store<u32>(iov, load<u32>(ptr + 4), sizeof<usize>())\n  let lf = calloc(8)\n  store<u8>(lf, 10)\n  store<u32>(iov, lf, sizeof<usize>() * 2)\n  store<u32>(iov, 1, sizeof<usize>() * 3)\n  let written_ptr = calloc(8)\n  fd_write(1, iov, 2, written_ptr)\n  free(written_ptr)\n  free(lf)\n  free(iov)\n}\n","export declare function malloc(bytes: u32): u32\nexport declare function free(ptr: u32): u32\nexport declare function incRef(ptr: u32): u32\nexport declare function decRef(ptr: u32): u32\n\nexport function calloc(nb: u32): u32 {\n  const ret = malloc(nb)\n  if (ret == -1) return ret\n  memory.fill(ret, 0, nb)\n  return ret\n}\n\nexport declare function throwError(code: u32, value1: u32, value2: u32): u32\n"]}