{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","stdlib-external/ascutils/tags.ts","stdlib-external/ascutils/primitives.ts","stdlib-external/ascutils/errors.ts","stdlib-external/hash.ts","stdlib-external/numbers.ts"],"names":[],"mappings":"+cKwDG,EAAK,KACL,AAAI,AAAU,EAAG,KACjB,EAAK,KAEL,AAAI,EAAI,KACR,AAAI,AAAU,EAAG,KACjB,AAAI,AAAC,EAAI,GAAK,QAad,AAAI,EAAI,KAER,AAAI,EAAK,EAAM,MACf,EAAK,SACL,AAAI,EAAK,EAAM,MACf,EAAK,SACL,AAAI,EAAK,EAAM,SAdf,EAAK,KACL,AAAI,AAAU,EAAG,KACjB,EAAK,KAEL,AAAI,EAAI,WAcR,AAAI,EAAQ,KAAgB,GAE5B,AAAI,AAAE,EAAM,MACV,AAAO,KACF,AAAI,AAAC,EAAM,GAA4B,KAC5C,AAAe,EAAM,KACrB,AAAkB,AAAU,OAC5B,AAAQ,EAAc,KACjB,AAAa,QAAG,EAAI,WACvB,AAAQ,AAAU,EAAW,MAAO,EAAQ,MADlB,EAAK,UAGjC,AAAS,KACJ,AAAI,AAAC,EAAM,GAA4B,KAC5C,AAAO,KACF,AAAI,AAAC,EAAM,GAA4B,KAC5C,AAAc,EAAM,KACpB,gBAAQ,AAAU,SACX,OAgBA,OAiBA,OAkBA,OAeA,OAUA,QA5EuB,EAC1B,AAAa,AAAU,OACvB,AAAY,EAAS,KACrB,AAAQ,EAAS,KACZ,AAAa,QAAG,EAAI,WACvB,AAAO,AAAU,EAAU,SADD,EAAK,UAGjC,AAAe,IACV,AAAa,QAAG,EAAI,WACvB,AAAM,EAAO,KACb,AAAM,EAAM,AAAS,EAAU,GAAI,UAFL,YAIhC,AAAI,EAAO,KAAG,AAAc,KAC5B,AAAS,IACT,MAEwB,EACxB,AAAa,AAAU,OAEvB,AAAa,EAAO,MAEpB,AAAI,AAAC,EAAO,IAAU,KACpB,AAAQ,KACH,AAAI,AAAC,EAAO,IAAU,MAC3B,AAAQ,KACH,AAAI,AAAC,EAAO,IAAU,MAC3B,AAAQ,KAER,AAAQ,OAEV,AAAO,EAAQ,KACf,MAEuB,EAEvB,AAAO,AAAU,OAEjB,AAAO,AAAU,OAEjB,AAAO,AAAU,OAEjB,AAAY,AAAU,OAEtB,AAAQ,EAAQ,KACX,AAAa,QAAG,EAAI,WACvB,AAAQ,AAAU,EAAU,MAAW,EAAQ,MADrB,EAAK,UAIjC,AAAS,IACT,MAE0B,EAE1B,AAAO,AAAU,OAEjB,AAAO,AAAU,OAEjB,AAAY,AAAU,OAEtB,AAAQ,EAAQ,KACX,AAAa,QAAG,EAAI,WACvB,AAAQ,AAAU,EAAU,MAAW,EAAQ,MADrB,EAAK,UAGjC,AAAS,IACT,MAEyB,EACzB,AAAY,AAAU,OAEtB,AAAQ,EAAQ,KACX,AAAa,QAAG,EAAI,WACvB,AAAQ,AAAU,EAAU,MAAW,EAAQ,MADrB,EAAK,UAGjC,AAAS,IACT,MAE6B,EAC7B,AAAU,EAAe,IC2D/B,AAAiB,EAAO,AAAC,YD1DnB,cAAQ,MACD,OAIA,OAKA,OAIA,OAKA,QAlB2B,EAC9B,AAAO,EAAiB,IC8DlC,AAAiB,EAAO,AAAC,YD7Df,MAE8B,EAC9B,AAAO,AAAU,OACjB,AAAO,AAAU,OACjB,MAEgC,EAChC,AAAO,AAAiB,EAAmB,ICiErD,AAAiB,EAAO,AAAC,aDhEf,MAEgC,EAChC,AAAO,AAAU,OACjB,AAAO,AAAU,OACjB,MAEiC,EACjC,AAAO,EAAuB,ICoExC,AAAiB,EAAO,AAAC,YDnEf,AAAO,EAAyB,ICyE1C,AAAiB,EAAO,AAAC,YDxEf,MAEO,EACP,AAAO,IACP,MAGJ,MAEO,AACA,MAGN,AAAI,EAAQ,KACjB,AAAO,KACF,AAAI,EAAQ,KACjB,AAAO,KACF,AAAI,EAAQ,KACjB,AAAO,KAEP,AAAO,cAKT,AAAI,IAEJ,AAAQ,EAAG,IACX,AAAS,IAIT,AAAO,EAAK","sourceRoot":"./hash.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","export const GRAIN_NUMBER_TAG_TYPE: i32       = 0b0000;\nexport const GRAIN_CONST_TAG_TYPE: i32        = 0b1111;\nexport const GRAIN_TUPLE_TAG_TYPE: i32        = 0b0001;\nexport const GRAIN_LAMBDA_TAG_TYPE: i32       = 0b0101;\nexport const GRAIN_GENERIC_HEAP_TAG_TYPE: i32 = 0b0011;\n\nexport const GRAIN_NUMBER_TAG_MASK: i32 = 0b0001;\nexport const GRAIN_GENERIC_TAG_MASK: i32 = 0b0111;\n\nexport const GRAIN_STRING_HEAP_TAG: i32 = 1;\nexport const GRAIN_CHAR_HEAP_TAG: i32 = 2;\nexport const GRAIN_ADT_HEAP_TAG: i32 = 3;\nexport const GRAIN_RECORD_HEAP_TAG: i32 = 4;\nexport const GRAIN_ARRAY_HEAP_TAG: i32 = 5;\nexport const GRAIN_BOXED_NUM_HEAP_TAG: i32 = 6;\n\nexport const GRAIN_FILE_DESCRIPTOR_TYPE_ID: i32 = 9;\n\n// Boxed number types\nexport const GRAIN_FLOAT32_BOXED_NUM_TAG = 1;\nexport const GRAIN_FLOAT64_BOXED_NUM_TAG = 2;\nexport const GRAIN_INT32_BOXED_NUM_TAG = 3;\nexport const GRAIN_INT64_BOXED_NUM_TAG = 4;\nexport const GRAIN_RATIONAL_BOXED_NUM_TAG = 5;\n","export const GRAIN_TRUE: u32 = 0xFFFFFFFF\nexport const GRAIN_FALSE: u32 = 0x7FFFFFFF\nexport const GRAIN_VOID: u32 = 0x6FFFFFFF\n","export const GRAIN_ERR_NOT_NUMBER_COMP: u32 = 0\nexport const GRAIN_ERR_NOT_NUMBER_ARITH: u32 = 1\nexport const GRAIN_ERR_NOT_BOOLEAN_LOGIC: u32 = 2\nexport const GRAIN_ERR_NOT_BOOLEAN_IF: u32 = 3\nexport const GRAIN_ERR_OVERFLOW: u32 = 4\nexport const GRAIN_ERR_GET_NOT_TUP: u32 = 5\nexport const GRAIN_ERR_GET_ITEM_IDX_NOT_NUMBER: u32 = 6\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_SMALL: u32 = 7\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_LARGE: u32 = 8\nexport const GRAIN_ERR_CALLED_NON_FUNCTION: u32 = 9\nexport const GRAIN_ERR_ARITY_MISMATCH: u32 = 10\nexport const GRAIN_ERR_OUT_OF_MEMORY: u32 = 11\nexport const GRAIN_ERR_SET_NOT_TUP: u32 = 12\nexport const GRAIN_ERR_SET_ITEM_IDX_NOT_NUMBER: u32 = 13\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_SMALL: u32 = 14\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_LARGE: u32 = 15\nexport const GRAIN_ERR_DIVISION_BY_ZERO: u32 = 17\nexport const GRAIN_ERR_MODULO_BY_ZERO: u32 = 18\nexport const GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS: u32 = 19\nexport const GRAIN_ERR_INVALID_ARGUMENT: u32 = 20\nexport const GRAIN_ERR_ASSERTION_ERROR: u32 = 21\nexport const GRAIN_ERR_FAILURE: u32 = 22\nexport const GRAIN_ERR_SYSTEM: u32 = 23\nexport const GRAIN_ERR_NOT_INTLIKE: u32 = 24\nexport const GRAIN_ERR_NOT_RATIONAL: u32 = 25\nexport const GRAIN_ERR_MALFORMED_UTF8: u32 = 26\nexport const GRAIN_ERR_NOT_ADT_VAL_GENERIC: u32 = 91\nexport const GRAIN_ERR_NOT_STRING_GENERIC: u32 = 93\nexport const GRAIN_ERR_NOT_BOOLEAN_GENERIC: u32 = 94\nexport const GRAIN_ERR_NOT_TUPLE_GENERIC: u32 = 95\nexport const GRAIN_ERR_NOT_LAMBDA_GENERIC: u32 = 96\nexport const GRAIN_ERR_BAD_INPUT: u32 = 97\nexport const GRAIN_ERR_NOT_NONNEG: u32 = 98\nexport const GRAIN_ERR_NOT_NUMBER_GENERIC: u32 = 99\n","/**\n  This module implements MurmurHash3 for Grain data types.\n  https://en.wikipedia.org/wiki/MurmurHash\n*/\n\nimport {\n  GRAIN_NUMBER_TAG_TYPE,\n  GRAIN_CONST_TAG_TYPE,\n  GRAIN_TUPLE_TAG_TYPE,\n  GRAIN_LAMBDA_TAG_TYPE,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n\n  GRAIN_NUMBER_TAG_MASK,\n  GRAIN_GENERIC_TAG_MASK,\n\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_ADT_HEAP_TAG,\n  GRAIN_RECORD_HEAP_TAG,\n  GRAIN_ARRAY_HEAP_TAG,\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n} from './ascutils/tags'\n\nimport {\n  GRAIN_TRUE,\n  GRAIN_FALSE,\n  GRAIN_VOID,\n} from './ascutils/primitives'\n\nimport {\n  boxedNumberTag,\n  boxedRationalNumerator,\n  boxedRationalDenominator,\n  boxedInt32Number,\n  boxedFloat32Number\n} from './numbers'\n\nconst seed: u32 = 0xe444\n\nconst MAX_HASH_DEPTH: u32 = 31\n\nconst c1: u32 = 0xcc9e2d51\nconst c2: u32 = 0x1b873593\nconst r1: u32 = 15\nconst r2: u32 = 13\nconst m: u32 = 5\nconst n: u32 = 0xe6546b64\n\nlet h = seed\n\nfunction hash32(k: u32): void {\n  k *= c1\n  k = rotl<i32>(k, r1)\n  k *= c2\n\n  h = h ^ k\n  h = rotl<i32>(h, r2)\n  h = (h * m) + n\n}\n\nfunction hashRemaining(r: u32): void {\n  // Note: wasm is little-endian so no swap is necessary\n  r *= c1\n  r = rotl<i32>(r, r1)\n  r *= c2\n\n  h = h ^ r\n}\n\nfunction finalize(len: u32): void {\n  h = h ^ len\n\n  h = h ^ (h >>> 16)\n  h *= 0x85ebca6b\n  h = h ^ (h >>> 13)\n  h *= 0xc2b2ae35\n  h = h ^ (h >>> 16)\n}\n\nfunction hashOne(val: u32, depth: u32): void {\n  if (depth > MAX_HASH_DEPTH) return\n\n  if (!(val & GRAIN_NUMBER_TAG_MASK)) {\n    hash32(val)\n  } else if ((val & GRAIN_GENERIC_TAG_MASK) === GRAIN_TUPLE_TAG_TYPE) {\n    let tuplePtr = val ^ GRAIN_TUPLE_TAG_TYPE\n    let tupleLength = load<u32>(tuplePtr)\n    let l = tupleLength * 4\n    for (let i: u32 = 0; i < l; i += 4) {\n      hashOne(load<u32>(tuplePtr + i, 4), depth + 1)\n    }\n    finalize(tupleLength)\n  } else if ((val & GRAIN_GENERIC_TAG_MASK) === GRAIN_LAMBDA_TAG_TYPE) {\n    hash32(val)\n  } else if ((val & GRAIN_GENERIC_TAG_MASK) === GRAIN_GENERIC_HEAP_TAG_TYPE) {\n    let heapPtr = val ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    switch (load<u32>(heapPtr)) {\n      case GRAIN_STRING_HEAP_TAG: {\n        let length = load<u32>(heapPtr, 4);\n        let extra = length % 4\n        let l = length - extra\n        for (let i: u32 = 0; i < l; i += 4) {\n          hash32(load<u32>(heapPtr + i, 8))\n        }\n        let rem: u32 = 0\n        for (let i: u32 = 0; i < extra; i++) {\n          rem = rem << 8\n          rem = rem | load<u8>(heapPtr + l + i, 8)\n        }\n        if (rem != 0) hashRemaining(rem)\n        finalize(length)\n        break\n      }\n      case GRAIN_CHAR_HEAP_TAG: {\n        const word = load<u32>(heapPtr, 4)\n        // little-endian byte order\n        const byte = word & 0xFF\n        let shift: u32\n        if ((byte & 0x80) === 0x00) {\n          shift = 24\n        } else if ((byte & 0xF0) === 0xF0) {\n          shift = 0\n        } else if ((byte & 0xE0) === 0xE0) {\n          shift = 8\n        } else {\n          shift = 16\n        }\n        hash32(word << shift)\n        break\n      }\n      case GRAIN_ADT_HEAP_TAG: {\n        // moduleId\n        hash32(load<u32>(heapPtr, 4))\n        // typeId\n        hash32(load<u32>(heapPtr, 8))\n        // variantId\n        hash32(load<u32>(heapPtr, 12))\n\n        let arity = load<u32>(heapPtr, 16)\n\n        let a = arity * 4\n        for (let i: u32 = 0; i < a; i += 4) {\n          hashOne(load<u32>(heapPtr + i, 5 * 4), depth + 1)\n        }\n\n        finalize(arity)\n        break\n      }\n      case GRAIN_RECORD_HEAP_TAG: {\n        // moduleId\n        hash32(load<u32>(heapPtr, 4))\n        // typeId\n        hash32(load<u32>(heapPtr, 8))\n\n        let arity = load<u32>(heapPtr, 12)\n\n        let a = arity * 4\n        for (let i: u32 = 0; i < a; i += 4) {\n          hashOne(load<u32>(heapPtr + i, 4 * 4), depth + 1)\n        }\n        finalize(arity)\n        break\n      }\n      case GRAIN_ARRAY_HEAP_TAG: {\n        let arity = load<u32>(heapPtr, 4)\n\n        let a = arity * 4\n        for (let i: u32 = 0; i < a; i += 4) {\n          hashOne(load<u32>(heapPtr + i, 2 * 4), depth + 1)\n        }\n        finalize(arity)\n        break\n      }\n      case GRAIN_BOXED_NUM_HEAP_TAG: {\n        let tag = boxedNumberTag(heapPtr)\n        switch (tag) {\n          case GRAIN_INT32_BOXED_NUM_TAG: {\n            hash32(boxedInt32Number(heapPtr))\n            break\n          }\n          case GRAIN_INT64_BOXED_NUM_TAG: {\n            hash32(load<u32>(heapPtr, 2 * 4))\n            hash32(load<u32>(heapPtr, 3 * 4))\n            break\n          }\n          case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n            hash32(reinterpret<u32>(boxedFloat32Number(heapPtr)))\n            break\n          }\n          case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n            hash32(load<u32>(heapPtr, 2 * 4))\n            hash32(load<u32>(heapPtr, 3 * 4))\n            break\n          }\n          case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n            hash32(boxedRationalNumerator(heapPtr))\n            hash32(boxedRationalDenominator(heapPtr))\n            break\n          }\n          default: {\n            hash32(heapPtr)\n            break\n          }\n        }\n        break\n      }\n      default: {\n        hash32(heapPtr)\n      }\n    }\n  } else if (val === GRAIN_TRUE) {\n    hash32(val)\n  } else if (val === GRAIN_FALSE) {\n    hash32(val)\n  } else if (val === GRAIN_VOID) {\n    hash32(val)\n  } else {\n    hash32(val)\n  }\n}\n\nexport function hash(a: u32): u32 {\n  h = seed\n\n  hashOne(a, 0)\n  finalize(0)\n\n  // Tag the number on the way out.\n  // Since Grain has proper modulus, negative numbers are okay.\n  return h << 1\n}\n","import {\n  GRAIN_NUMBER_TAG_TYPE,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n\n  GRAIN_NUMBER_TAG_MASK,\n  GRAIN_GENERIC_TAG_MASK,\n\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n} from './ascutils/tags'\n\nimport {\n  GRAIN_ERR_OVERFLOW,\n  GRAIN_ERR_DIVISION_BY_ZERO,\n  GRAIN_ERR_NOT_INTLIKE,\n  GRAIN_ERR_NOT_RATIONAL,\n  GRAIN_ERR_MODULO_BY_ZERO,\n} from './ascutils/errors'\n\nimport {\n  GRAIN_TRUE,\n  GRAIN_FALSE,\n} from './ascutils/primitives'\n\nimport { throwError } from './ascutils/grainRuntime'\n\nimport {\n  newRational,\n  newInt32,\n  newInt64,\n  newFloat32,\n  newFloat64\n} from './ascutils/dataStructures'\n\nexport {\n  newRational,\n  newInt32,\n  newInt64,\n  newFloat32,\n  newFloat64\n}\n\n// [TODO] (#301) pretty much all of the overflow values we pass here are suboptimal...really need to rework this\n// @ts-ignore: decorator\n@inline\nfunction throwOverflowError(x: u32): u32 {\n  return throwError(GRAIN_ERR_OVERFLOW, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwDivideByZero(): u32 {\n  return throwError(GRAIN_ERR_DIVISION_BY_ZERO, 0, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwNotIntLike(x: u32): u32 {\n  return throwError(GRAIN_ERR_NOT_INTLIKE, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction throwNotRational(x: u32): u32 {\n  return throwError(GRAIN_ERR_NOT_RATIONAL, x, 0)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction encodeBool(b: bool): u32 {\n  return b ? GRAIN_TRUE : GRAIN_FALSE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction tagSimple(x: i32): u32 {\n  return x << 1\n}\n\n// @ts-ignore: decorator\n@inline\nfunction untagSimple(x: u32): i32 {\n  return <i32>(x) >> 1\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI64toI32(x: i64): i32 {\n  if (x > I32.MAX_VALUE || x < I32.MIN_VALUE) {\n    return throwOverflowError(<u32>(x))\n  } else {\n    return <i32>(x)\n  }\n}\n\n// https://en.wikipedia.org/wiki/Binary_GCD_algorithm\nfunction gcdHelp(x: i64, y: i64): i64 {\n  if (x == y) {\n    return y\n  }\n  if (x == 0) {\n    return y\n  }\n  if (y == 0) {\n    return x\n  }\n  if ((~x & 1) != 0) {\n    // x is even\n    if ((y & 1) != 0) {\n      // y is odd\n      return gcdHelp(x >> 1, y)\n    } else {\n      return gcdHelp(x >> 1, y >> 1) << 1\n    }\n  }\n  if ((~y & 1) != 0) {\n    // y is even and x is odd\n    return gcdHelp(x, y >> 1)\n  }\n  if (x > y) {\n    return gcdHelp(x - y, y)\n  }\n  return gcdHelp(y - x, x)\n}\n\nfunction gcd(x: i64, y: i64): i64 {\n  // Algorithm above breaks on negatives, so\n  // we make sure that they are positive at the beginning\n  return gcdHelp(abs<i64>(x), abs<i64>(y))\n}\n\nfunction gcd32(x: i32, y: i32): i32 {\n  return <i32>(gcd(<i64>(x), <i64>(y)))\n}\n\n\nfunction reducedFraction(x: i32, y: i32): u32 {\n  if (y < 0) {\n    // Normalization 1: Never do negative/negative\n    // Normalization 2: Never allow a negative denominator\n    x = -x\n    y = -y\n  }\n  if (y == 0) {\n    return throwDivideByZero()\n  }\n  if (x % y == 0) {\n    // Avoid allocation if possible\n    return reducedInteger(<i64>(x) / <i64>(y))\n  }\n  // x not evenly divisible by y\n  let factor = gcd32(x, y)\n  return newRational(x / factor, y / factor)\n}\n\nfunction reducedFraction64(x: i64, y: i64): u32 {\n  if (y < 0) {\n    // Normalization 1: Never do negative/negative\n    // Normalization 2: Never allow a negative denominator\n    x = -x\n    y = -y\n  }\n  if (y == 0) {\n    return throwDivideByZero()\n  }\n  if (x % y == 0) {\n    return reducedInteger(x / y)\n  }\n  let factor = gcd(x, y)\n  let xdiv = safeI64toI32(x / factor)\n  let ydiv = safeI64toI32(y / factor)\n  return newRational(xdiv, ydiv)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction reducedInteger(x: i64): u32 {\n  if ((x > I32.MAX_VALUE) || (x < I32.MIN_VALUE)) {\n    return newInt64(x)\n  } else if ((x > (I32.MAX_VALUE >> 1)) || (x < (I32.MIN_VALUE >> 1))) {\n    return newInt32(<i32>(x))\n  } else {\n    return tagSimple(<i32>(x))\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI32Multiply(x: i32, y: i32): i32 {\n  let prod = <i64>(x) * <i64>(y)\n  if (prod > I32.MAX_VALUE || prod < I32.MIN_VALUE) {\n    return throwOverflowError(<u32>(x))\n  }\n  return <i32>(prod);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction safeI64Multiply(x: i64, y: i64): i64 {\n  let prod = x * y\n  if (x != 0 && prod / x != y) {\n    // [TODO] (#301) just passing x is kind of bad UX\n    // [TODO] (#302) once we have exception handling, this will leak\n    return throwOverflowError(newInt64(x))\n  }\n  return prod;\n}\n\n// Accessor functions\n\n/* Memory Layout:\n * [GRAIN_BOXED_NUM_HEAP_TAG : u32, <boxed_num tag> : u32, <number-specific payload>...]\n * (payload depends on boxed_num tag...see below)\n *\n * Payloads:\n * For Int32:\n * [number: i32]\n *\n * For Int64:\n * [number: i64]\n *\n * For Float32:\n * [number: f32]\n *\n * For Float64:\n * [number: f64]\n *\n * For Rational:\n * [numerator: i32, denominator: u32]\n */\n\n// @ts-ignore: decorator\n@inline\nexport function boxedNumberTag(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 1 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedInt32Number(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedInt64Number(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedFloat32Number(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedFloat64Number(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function boxedRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n\nfunction coerceFloat32(x: u32): f32 {\n  if (isSimpleNumber(x)) {\n    return <f32>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <f32>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return <f32>(boxedInt64Number(x))\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return <f32>(boxedRationalNumerator(x)) / <f32>(boxedRationalDenominator(x))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return boxedFloat32Number(x)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let xval = boxedFloat64Number(x)\n      if (xval > F32.MAX_VALUE || xval < F32.MIN_VALUE) {\n        // Not an actual return value\n        throwOverflowError(x)\n        return unreachable()\n      } else {\n        return <f32>(xval)\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction coerceFloat64(x: u32): f64 {\n  if (isSimpleNumber(x)) {\n    return <f64>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <f64>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return <f64>(boxedInt64Number(x))\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return <f64>(boxedRationalNumerator(x)) / <f64>(boxedRationalDenominator(x))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return <f64>(boxedFloat32Number(x))\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return boxedFloat64Number(x)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction coerceInt64(x: u32): i64 {\n  if (isSimpleNumber(x)) {\n    return <i64>(untagSimple(x))\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return <i64>(boxedInt32Number(x))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return boxedInt64Number(x)\n    } default: {\n      // rationals are never integral, and we refuse to coerce floats to ints\n      return throwNotIntLike(x)\n    }\n  }\n}\n\nfunction coerceInt32(x: u32): i32 {\n  let asInt64 = coerceInt64(x)\n  if (asInt64 > <i64>(I32.MAX_VALUE) || asInt64 < <i64>(I32.MIN_VALUE)) {\n    return throwOverflowError(x)\n  }\n  return <i32>(asInt64)\n}\n\n// @ts-ignore: decorator\n@inline\nfunction isSimpleNumber(x: u32): bool {\n  return (x & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nfunction isBoxedNumber(x: u32): bool {\n  return ((x & GRAIN_GENERIC_TAG_MASK) == GRAIN_GENERIC_HEAP_TAG_TYPE) &&\n    ((load<u32>(x ^ GRAIN_GENERIC_HEAP_TAG_TYPE) == GRAIN_BOXED_NUM_HEAP_TAG))\n}\n\n// @ts-ignore: decorator\n@inline\nfunction boxedNumberPtr(x: u32): u32 {\n  return x ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isNumber(x: u32): bool {\n  // x is a number if it is a literal number or a boxed_num heap value\n  return isSimpleNumber(x) || isBoxedNumber(x)\n}\n\n/** Number-aware equality checking\n  * The basic idea is that we first figure out the type of the\n  * number on the LHS, and then figure out if the RHS number is equal\n  * to that number\n  *\n  * NOTE: The preconditions in these functions are important, so do NOT\n  *       export them!\n  */\n\nfunction numberEqualSimpleHelp(x: u32, yTagged: u32): bool {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and x !== y and isNumber(y)\n  if (isSimpleNumber(yTagged)) {\n    // x !== y, so they must be different\n    return false\n  }\n  let xval = untagSimple(x) // <- actual int value of x\n  let y = boxedNumberPtr(yTagged)\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return <i32>(xval) == yBoxedVal\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return <i64>(xval) == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      return false\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      return F32.isSafeInteger(yBoxedVal) && <i64>(xval) == <i64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      return F64.isSafeInteger(yBoxedVal) && <i64>(xval) == <i64>(yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n\nfunction numberEqualInt64Help(xBoxedVal: i64, y: u32): bool {\n  // PRECONDITION: x !== y and isNumber(y)\n  // Basic number:\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return xBoxedVal == <i64>(untagSimple(y))\n  }\n  // Boxed number:\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return xBoxedVal == <i64>(yBoxedVal)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return xBoxedVal == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      return false\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      return F32.isSafeInteger(yBoxedVal) && xBoxedVal == <i64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      return F64.isSafeInteger(yBoxedVal) && xBoxedVal == <i64>(yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualInt32Help(xBoxedVal: i32, y: u32): bool {\n  // We can just pretend it's 64-bit for the equality check\n  return numberEqualInt64Help(<i64>(xBoxedVal), y)\n}\n\nfunction numberEqualRationalHelp(xptr: u32, y: u32): bool {\n  // PRECONDITION: x is rational and x !== y and isNumber(y)\n  // Basic number: (we know it's not equal, since we never store ints as rationals)\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return false\n  }\n  let xNumerator = boxedRationalNumerator(xptr)\n  let xDenominator = boxedRationalDenominator(xptr)\n  // Boxed number:\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return false\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      return false\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      return (xNumerator == yNumerator) && (xDenominator == yDenominator)\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      let xAsFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return xAsFloat == yBoxedVal\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      let xAsFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return xAsFloat == yBoxedVal\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualFloat64Help(x: f64, y: u32): bool {\n  let xIsInteger = F64.isInteger(x)\n  // Basic number:\n  if ((y & GRAIN_NUMBER_TAG_MASK) == GRAIN_NUMBER_TAG_TYPE) {\n    return xIsInteger && x == <f64>(untagSimple(y))\n  }\n  // Boxed number\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      return F64.isSafeInteger(x) && <i64>(x) == <i64>(yBoxedVal)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      return F64.isSafeInteger(x) && <i64>(x) == yBoxedVal\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      let yAsFloat = <f64>(yNumerator) / <f64>(yDenominator)\n      return x == yAsFloat\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return x == <f64>(yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      // [TODO] (#303) maybe we should have some sort of tolerance?\n      return x == yBoxedVal\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberEqualFloat32Help(x: f32, y: u32): bool {\n  return numberEqualFloat64Help(<f64>(x), y)\n}\n\nexport function numberEqual(x: u32, y: u32): bool {\n  // Short circuit if value/pointer is the same\n  if (x === y) return true\n  if (!isNumber(x)) return false\n  if (!isNumber(y)) return false\n  if (isSimpleNumber(x)) {\n    return numberEqualSimpleHelp(x, y)\n  }\n  // Boxed number\n  let xBoxedNumberTag = boxedNumberTag(x)\n  switch (xBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let xBoxedVal = boxedInt32Number(x)\n      return numberEqualInt32Help(xBoxedVal, y)\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let xBoxedVal = boxedInt64Number(x)\n      return numberEqualInt64Help(xBoxedVal, y)\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberEqualRationalHelp(x, y)\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberEqualFloat32Help(boxedFloat32Number(x), y)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberEqualFloat64Help(boxedFloat64Number(x), y)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n/*\n * ===== PLUS & MINUS =====\n * (same schema as equal())\n */\n\nfunction numberPlusMinusSimpleHelp(x: u32, y: u32, isMinus: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    return reducedInteger(<i64>(untagSimple(x)) + <i64>(untagSimple(y) * (isMinus ? -1 : 1)))\n  }\n  let xval = untagSimple(x) // <- actual int value of x\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y) * (isMinus ? -1 : 1)\n      return reducedInteger(<i64>(xval) + <i64>(yBoxedVal))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y) * (isMinus ? -1 : 1)\n      let xval64 = <i64>(xval)\n      let sum = xval64 + yBoxedVal\n      if (yBoxedVal >= 0 && sum < xval64) {\n        return throwOverflowError(y)\n      } else if (yBoxedVal < 0 && sum > xval64) {\n        return throwOverflowError(y)\n      } else {\n        return reducedInteger(sum)\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      let expandedXNumerator = safeI64Multiply(<i64>(xval), yDenominator)\n      let sum = <i64>(expandedXNumerator) + <i64>(yNumerator)\n      if (sum < I32.MIN_VALUE || sum > I32.MAX_VALUE) {\n        return throwOverflowError(y)\n      }\n      return reducedFraction64(sum, <i64>(yDenominator))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y) * (isMinus ? -1.0 : 1.0)\n      // [TODO] (#304) is this safe?\n      return newFloat32(<f32>(xval) + yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n      return newFloat64(<f64>(xval) + yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberPlusMinusInt64Help(xval: i64, y: u32, isMinus: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    let yval = <i64>(untagSimple(y) * (isMinus ? -1 : 1))\n    let sum = xval + yval\n    if (yval >= 0 && sum < xval) {\n      return throwOverflowError(y)\n    } else if (yval < 0 && sum > xval) {\n      return throwOverflowError(y)\n    }\n    return reducedInteger(sum)\n  }\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y) * (isMinus ? -1 : 1)\n      return reducedInteger(xval + <i64>(yBoxedVal))\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y) * (isMinus ? -1 : 1)\n      let xval64 = xval\n      let sum = xval64 + yBoxedVal\n      if (yBoxedVal >= 0 && sum < xval64) {\n        return throwOverflowError(y)\n      } else if (yBoxedVal < 0 && sum > xval64) {\n        return throwOverflowError(y)\n      } else {\n        return reducedInteger(sum)\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      let expandedXNumerator = safeI64Multiply(xval, yDenominator)\n      let sum = expandedXNumerator + <i64>(yNumerator)\n      if (sum < I32.MIN_VALUE || sum > I32.MAX_VALUE) {\n        return throwOverflowError(y)\n      }\n      return reducedFraction64(sum, <i64>(yDenominator))\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y) * (isMinus ? -1.0 : 1.0)\n      // [TODO] (#304) this isn't safe enough\n      return newFloat32(<f32>(xval) + yBoxedVal)\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n      return newFloat64(<f64>(xval) + yBoxedVal)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberPlusMinusRationalHelp(x: u32, y: u32, isMinus: bool): u32 {\n  if (isSimpleNumber(y)) {\n    return numberPlusMinusSimpleHelp(y, x, isMinus)\n  }\n  let ytag = boxedNumberTag(y)\n  switch (ytag) {\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // The one case we don't delegate is rational +/- rational\n      let xNumerator = boxedRationalNumerator(x)\n      let xDenominator = boxedRationalDenominator(x)\n      let yNumerator = boxedRationalNumerator(y) * (isMinus ? -1 : 1)\n      let yDenominator = boxedRationalDenominator(y)\n      // [TODO] {#304) this could be written in a more overflow-proof way\n      if (xDenominator == yDenominator) {\n        return reducedFraction64(<i64>(xNumerator) + <i64>(yNumerator), xDenominator)\n      }\n      let numerator1 = safeI64Multiply(xNumerator, yDenominator)\n      let numerator2 = safeI64Multiply(yNumerator, xDenominator)\n      let numerator = numerator1 + numerator2\n      let denominator = safeI64Multiply(xDenominator, yDenominator)\n      return reducedFraction64(numerator, denominator)\n    } case GRAIN_INT32_BOXED_NUM_TAG:\n    case GRAIN_INT64_BOXED_NUM_TAG:\n    case GRAIN_FLOAT32_BOXED_NUM_TAG:\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberPlusMinusHelp(y, x, isMinus)\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\n\nfunction numberPlusMinusFloat32Help(xval: f32, y: u32, isMinus: bool): u32 {\n  if (!isSimpleNumber(y) && boxedNumberTag(y) == GRAIN_FLOAT64_BOXED_NUM_TAG) {\n    // Special case: promote to f64 if RHS is f64\n    let yval = boxedFloat64Number(y) * <f64>(isMinus ? -1.0 : 1.0)\n    return newFloat64(<f64>(xval) + yval)\n  } else {\n    let yval = coerceFloat32(y) * (isMinus ? -1.0 : 1.0)\n    return newFloat32(xval + yval)\n  }\n}\n\nfunction numberPlusMinusFloat64Help(xval: f64, y: u32, isMinus: bool): u32 {\n  let yval = coerceFloat64(y) * <f64>(isMinus ? -1.0 : 1.0)\n  return newFloat64(xval + yval)\n}\n\n\nfunction numberPlusMinusInt32Help(xval: i32, y: u32, isMinus: bool): u32 {\n  return numberPlusMinusInt64Help(<i64>(xval), y, isMinus)\n}\n\nfunction numberPlusMinusHelp(x: u32, y: u32, isMinus: bool): u32 {\n  if (isSimpleNumber(x)) {\n    return numberPlusMinusSimpleHelp(x, y, isMinus)\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return numberPlusMinusInt32Help(boxedInt32Number(x), y, isMinus)\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      return numberPlusMinusInt64Help(boxedInt64Number(x), y, isMinus)\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberPlusMinusRationalHelp(x, y, isMinus)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberPlusMinusFloat32Help(boxedFloat32Number(x), y, isMinus)\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberPlusMinusFloat64Help(boxedFloat64Number(x), y, isMinus)\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n\nexport function numberPlus(x: u32, y: u32): u32 {\n  return numberPlusMinusHelp(x, y, false)\n}\n\nexport function numberMinus(x: u32, y: u32): u32 {\n  return numberPlusMinusHelp(x, y, true)\n}\n\n/*\n * ===== TIMES & DIVIDE =====\n * (same schema as equal())\n */\n\nfunction numberTimesDivideSimpleHelp(x: u32, y: u32, isDivide: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  let xval = untagSimple(x) // <- actual int value of x\n  return numberTimesDivideInt64Help(<i64>(xval), y, isDivide)\n}\n\nfunction numberTimesDivideInt32Help(xval: i32, y: u32, isDivide: bool): u32 {\n  return numberTimesDivideInt64Help(<i64>(xval), y, isDivide)\n}\n\nfunction numberTimesDivideInt64Help(xval: i64, y: u32, isDivide: bool): u32 {\n  // PRECONDITION: x is a \"simple\" number (value tag is 0) and isNumber(y)\n  if (isSimpleNumber(y)) {\n    if (isDivide) {\n      return reducedFraction64(xval, <i64>(untagSimple(y)))\n    } else {\n      return reducedInteger(safeI64Multiply(xval, <i64>(untagSimple(y))))\n    }\n  }\n  let yBoxedNumberTag = boxedNumberTag(y)\n  switch (yBoxedNumberTag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt32Number(y)\n      if (isDivide) {\n        return reducedFraction64(xval, <i64>(yBoxedVal))\n      } else {\n        return reducedInteger(safeI64Multiply(xval, <i64>(yBoxedVal)))\n      }\n    } case GRAIN_INT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedInt64Number(y)\n      if (isDivide) {\n        return reducedFraction64(xval, yBoxedVal)\n      } else {\n        return reducedInteger(safeI64Multiply(xval, yBoxedVal))\n      }\n    } case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      // NOTE: we always store in most reduced form, so a rational and an int are never equal\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      if (isDivide) {\n        // x / (a / b) == (x * b) / a\n        let numerator = safeI64Multiply(xval, yDenominator)\n        return reducedFraction64(numerator, yNumerator)\n      } else {\n        // x * (a / b) == (x * a) / b\n        let numerator = safeI64Multiply(xval, yNumerator)\n        return reducedFraction64(numerator, yDenominator)\n      }\n    } case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat32Number(y)\n      // [TODO] (#304) is this safe?\n      if (isDivide) {\n        return newFloat32(<f32>(xval) / yBoxedVal)\n      } else {\n        return newFloat32(<f32>(xval) * yBoxedVal)\n      }\n    } case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let yBoxedVal = boxedFloat64Number(y)\n      if (isDivide) {\n        return newFloat64(<f64>(xval) / yBoxedVal)\n      } else {\n        return newFloat64(<f64>(xval) * yBoxedVal)\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberTimesDivideRationalHelp(x: u32, y: u32, isDivide: bool): u32 {\n  // Division isn't commutative, so we actually need to do the work\n  let xNumerator = boxedRationalNumerator(x)\n  let xDenominator = boxedRationalDenominator(x)\n  if (isSimpleNumber(y)) {\n    if (isDivide) {\n      // (a / b) / y == a / (b * y)\n      let denominator = safeI64Multiply(xDenominator, <i64>(untagSimple(y)))\n      return reducedFraction64(xNumerator, denominator)\n    } else {\n      // (a / b) * y == (a * y) / b\n      let numerator = safeI64Multiply(xNumerator, <i64>(untagSimple(y)))\n      return reducedFraction64(numerator, xDenominator)\n    }\n  }\n  let ytag = boxedNumberTag(y)\n  switch (ytag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      // Same idea as above\n      if (isDivide) {\n        // (a / b) / y == a / (b * y)\n        let denominator = safeI64Multiply(xDenominator, <i64>(boxedInt32Number(y)))\n        return reducedFraction64(xNumerator, denominator)\n      } else {\n        // (a / b) * y == (a * y) / b\n        let numerator = safeI64Multiply(xNumerator, <i64>(boxedInt32Number(y)))\n        return reducedFraction64(numerator, xDenominator)\n      }\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      // Same idea as above\n      if (isDivide) {\n        // (a / b) / y == a / (b * y)\n        let denominator = safeI64Multiply(xDenominator, boxedInt64Number(y))\n        return reducedFraction64(xNumerator, denominator)\n      } else {\n        // (a / b) * y == (a * y) / b\n        let numerator = safeI64Multiply(xNumerator, boxedInt64Number(y))\n        return reducedFraction64(numerator, xDenominator)\n      }\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      let xNumerator = boxedRationalNumerator(x)\n      let xDenominator = boxedRationalDenominator(x)\n      let yNumerator = boxedRationalNumerator(y)\n      let yDenominator = boxedRationalDenominator(y)\n      // (a / b) * (c / d) == (a * c) / (b * d)\n      // (a / b) / (c / d) == (a * d) / (b * c)\n      // [TODO] (#304) this could maybe be written in a more overflow-proof way\n      let numerator = isDivide ? safeI64Multiply(xNumerator, yDenominator) : safeI64Multiply(xNumerator, yNumerator)\n      let denominator = isDivide ? safeI64Multiply(xDenominator, yNumerator) : safeI64Multiply(xDenominator, yDenominator)\n      return reducedFraction64(numerator, denominator)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      let asFloat = <f32>(xNumerator) / <f32>(xDenominator)\n      if (isDivide) {\n        return newFloat32(asFloat / boxedFloat32Number(y))\n      } else {\n        return newFloat32(asFloat * boxedFloat32Number(y))\n      }\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      let asFloat = <f64>(xNumerator) / <f64>(xDenominator)\n      if (isDivide) {\n        return newFloat64(asFloat / boxedFloat64Number(y))\n      } else {\n        return newFloat64(asFloat * boxedFloat64Number(y))\n      }\n    } default: {\n      return unreachable()\n    }\n  }\n}\n\nfunction numberTimesDivideFloat64Help(x: f64, y: u32, isDivide: bool): u32 {\n  let yAsFloat = coerceFloat64(y)\n  if (isDivide) {\n    return newFloat64(x / yAsFloat)\n  } else {\n    return newFloat64(x * yAsFloat)\n  }\n}\n\nfunction numberTimesDivideFloat32Help(x: f32, y: u32, isDivide: bool): u32 {\n  if (isBoxedNumber(y) && boxedNumberTag(y) == GRAIN_INT64_BOXED_NUM_TAG) {\n    // Special case: f32->f64 promotion\n    if (isDivide) {\n      return newFloat64(<f64>(x) / boxedFloat64Number(y))\n    } else {\n      return newFloat64(<f64>(x) * boxedFloat64Number(y))\n    }\n  }\n  let yAsFloat = coerceFloat32(y)\n  if (isDivide) {\n    return newFloat32(x / yAsFloat)\n  } else {\n    return newFloat32(x * yAsFloat)\n  }\n}\n\nfunction numberTimesDivideHelp(x: u32, y: u32, isDivide: bool): u32 {\n  if (isSimpleNumber(x)) {\n    return numberTimesDivideSimpleHelp(x, y, isDivide)\n  }\n  let xtag = boxedNumberTag(x)\n  switch (xtag) {\n    case GRAIN_INT32_BOXED_NUM_TAG: {\n      return numberTimesDivideInt32Help(boxedInt32Number(x), y, isDivide)\n    }\n    case GRAIN_INT64_BOXED_NUM_TAG: {\n      return numberTimesDivideInt64Help(boxedInt64Number(x), y, isDivide)\n    }\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return numberTimesDivideRationalHelp(x, y, isDivide)\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return numberTimesDivideFloat32Help(boxedFloat32Number(x), y, isDivide)\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return numberTimesDivideFloat64Help(boxedFloat64Number(x), y, isDivide)\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n\nexport function numberTimes(x: u32, y: u32): u32 {\n  return numberTimesDivideHelp(x, y, false)\n}\n\nexport function numberDivide(x: u32, y: u32): u32 {\n  return numberTimesDivideHelp(x, y, true)\n}\n\n/*\n * ===== MODULO =====\n * (same schema as equal())\n */\n\nexport function numberMod(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  if (yval == 0) {\n    return throwError(GRAIN_ERR_MODULO_BY_ZERO, 0, 0)\n  }\n  // AssemblyScript's % is the remainder operator, so we implement modulo manually\n  if (xval < 0 && yval > 0 || xval > 0 && yval < 0) {\n    let modval = abs<i64>(xval) % abs<i64>(yval)\n    return reducedInteger(modval != 0 ? (abs<i64>(yval) - modval) * (yval < 0 ? -1 : 1) : modval)\n  } else {\n    return reducedInteger(xval % yval)\n  }\n}\n\n/*\n * ===== LESS THAN / GREATER THAN / LESS EQUAL / GREATER EQUAL =====\n * Coerce to float64 and then do comparisons\n * [TODO] (#305) Could probably be made more efficient\n */\n// [TODO] (#305) is this safe? I think it's safe?\nexport function numberLess(x: u32, y: u32): u32 {\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  return encodeBool(xval < yval)\n}\n\nexport function numberGreater(x: u32, y: u32): u32 {\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  return encodeBool(xval > yval)\n}\n\nexport function numberLessEqual(x: u32, y: u32): u32 {\n  // Equality is finicky, so delegate\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  if (xval < yval) {\n    return encodeBool(true)\n  } else {\n    return encodeBool(numberEqual(x, y))\n  }\n}\n\nexport function numberGreaterEqual(x: u32, y: u32): u32 {\n  // Equality is finicky, so delegate\n  let xval = coerceFloat64(x)\n  let yval = coerceFloat64(y)\n  if (xval > yval) {\n    return encodeBool(true)\n  } else {\n    return encodeBool(numberEqual(x, y))\n  }\n}\n\n/*\n * ===== EQUAL =====\n */\n\nexport function numberEq(x: u32, y: u32): u32 {\n  return encodeBool(numberEqual(x, y))\n}\n\n/*\n * ===== LOGICAL OPERATIONS =====\n * Only valid for int-like numbers. Coerce to i64 and do operations\n */\n// [TODO] (#306) Semantics around when things should stay i32/i64\n\nexport function numberLnot(x: u32): u32 {\n  let xval = coerceInt64(x)\n  return reducedInteger(~xval)\n}\n\nexport function numberLsl(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval << yval)\n}\n\nexport function numberLsr(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval >>> yval)\n}\n\nexport function numberLand(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval & yval)\n}\n\nexport function numberLor(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval | yval)\n}\n\nexport function numberLxor(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval ^ yval)\n}\n\nexport function numberAsr(x: u32, y: u32): u32 {\n  let xval = coerceInt64(x)\n  let yval = coerceInt64(y)\n  return reducedInteger(xval >> yval)\n}\n\n// inc/dec\n\nexport function numberIncr(x: u32): u32 {\n  return numberPlus(x, tagSimple(1));\n}\n\nexport function numberDecr(x: u32): u32 {\n  return numberMinus(x, tagSimple(1));\n}\n\n\n/// USER-EXPOSED COERCION FUNCTIONS\n//\n// [NOTE]: Coercion is a *conservative* process! For example, even if a float is 1.0,\n//         we will fail if attempting to coerce to an int!\n\nexport function coerceNumberToInt32(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_INT32_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  // can possibly fail\n  return newInt32(coerceInt32(x))\n}\n\nexport function coerceNumberToInt64(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_INT64_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newInt64(coerceInt64(x))\n}\n\nexport function coerceNumberToRational(x: u32): u32 {\n  if (isSimpleNumber(x)) {\n    return newRational(x >> 1, 1)\n  }\n  let tag = boxedNumberTag(x)\n  if (tag == GRAIN_RATIONAL_BOXED_NUM_TAG) {\n    return x\n  }\n  if (tag == GRAIN_INT32_BOXED_NUM_TAG) {\n    return newRational(boxedInt32Number(x), 1)\n  }\n  if (tag == GRAIN_INT64_BOXED_NUM_TAG) {\n    return newRational(coerceInt32(x), 1)\n  }\n  return throwNotRational(x)\n}\n\nexport function coerceNumberToFloat32(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_FLOAT32_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newFloat32(coerceFloat32(x))\n}\n\nexport function coerceNumberToFloat64(x: u32): u32 {\n  if (!isSimpleNumber(x) && boxedNumberTag(x) == GRAIN_FLOAT64_BOXED_NUM_TAG) {\n    // avoid extra malloc\n    return x\n  }\n  return newFloat64(coerceFloat64(x))\n}\n\nexport function coerceInt32ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceInt64ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceRationalToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceFloat32ToNumber(x: u32): u32 {\n  return x\n}\n\nexport function coerceFloat64ToNumber(x: u32): u32 {\n  return x\n}\n\n/// USER-EXPOSED CONVERSION FUNCTIONS\n\nexport function convertExactToInexact(x: u32): u32 {\n  return x\n}\n\nexport function convertInexactToExact(x: u32): u32 {\n  if (isSimpleNumber(x)) {\n    return x\n  }\n  let tag = boxedNumberTag(x)\n  if (tag == GRAIN_INT32_BOXED_NUM_TAG || tag == GRAIN_INT64_BOXED_NUM_TAG || tag == GRAIN_RATIONAL_BOXED_NUM_TAG) {\n    return x\n  }\n  switch (tag) {\n    case GRAIN_INT32_BOXED_NUM_TAG:\n    case GRAIN_INT64_BOXED_NUM_TAG:\n    case GRAIN_RATIONAL_BOXED_NUM_TAG: {\n      return x\n    }\n    case GRAIN_FLOAT32_BOXED_NUM_TAG: {\n      return reducedInteger(<i64>(<f32>(nearest(boxedFloat32Number(x)))))\n    }\n    case GRAIN_FLOAT64_BOXED_NUM_TAG: {\n      return reducedInteger(<i64>(<f64>(nearest(boxedFloat64Number(x)))))\n    }\n    default: {\n      return unreachable()\n    }\n  }\n}\n"]}