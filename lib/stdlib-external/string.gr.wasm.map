{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","stdlib-external/ascutils/errors.ts","stdlib-external/ascutils/tags.ts","stdlib-external/ascutils/primitives.ts","stdlib-external/string.ts","stdlib-external/ascutils/dataStructures.ts","~lib/memory.ts","~lib/util/memory.ts"],"names":[],"mappings":"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","sourceRoot":"./string.gr.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","export const GRAIN_ERR_NOT_NUMBER_COMP: u32 = 0\nexport const GRAIN_ERR_NOT_NUMBER_ARITH: u32 = 1\nexport const GRAIN_ERR_NOT_BOOLEAN_LOGIC: u32 = 2\nexport const GRAIN_ERR_NOT_BOOLEAN_IF: u32 = 3\nexport const GRAIN_ERR_OVERFLOW: u32 = 4\nexport const GRAIN_ERR_GET_NOT_TUP: u32 = 5\nexport const GRAIN_ERR_GET_ITEM_IDX_NOT_NUMBER: u32 = 6\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_SMALL: u32 = 7\nexport const GRAIN_ERR_GET_ITEM_IDX_TOO_LARGE: u32 = 8\nexport const GRAIN_ERR_CALLED_NON_FUNCTION: u32 = 9\nexport const GRAIN_ERR_ARITY_MISMATCH: u32 = 10\nexport const GRAIN_ERR_OUT_OF_MEMORY: u32 = 11\nexport const GRAIN_ERR_SET_NOT_TUP: u32 = 12\nexport const GRAIN_ERR_SET_ITEM_IDX_NOT_NUMBER: u32 = 13\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_SMALL: u32 = 14\nexport const GRAIN_ERR_SET_ITEM_IDX_TOO_LARGE: u32 = 15\nexport const GRAIN_ERR_DIVISION_BY_ZERO: u32 = 17\nexport const GRAIN_ERR_MODULO_BY_ZERO: u32 = 18\nexport const GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS: u32 = 19\nexport const GRAIN_ERR_INVALID_ARGUMENT: u32 = 20\nexport const GRAIN_ERR_ASSERTION_ERROR: u32 = 21\nexport const GRAIN_ERR_FAILURE: u32 = 22\nexport const GRAIN_ERR_SYSTEM: u32 = 23\nexport const GRAIN_ERR_NOT_INTLIKE: u32 = 24\nexport const GRAIN_ERR_NOT_RATIONAL: u32 = 25\nexport const GRAIN_ERR_MALFORMED_UTF8: u32 = 26\nexport const GRAIN_ERR_NOT_ADT_VAL_GENERIC: u32 = 91\nexport const GRAIN_ERR_NOT_STRING_GENERIC: u32 = 93\nexport const GRAIN_ERR_NOT_BOOLEAN_GENERIC: u32 = 94\nexport const GRAIN_ERR_NOT_TUPLE_GENERIC: u32 = 95\nexport const GRAIN_ERR_NOT_LAMBDA_GENERIC: u32 = 96\nexport const GRAIN_ERR_BAD_INPUT: u32 = 97\nexport const GRAIN_ERR_NOT_NONNEG: u32 = 98\nexport const GRAIN_ERR_NOT_NUMBER_GENERIC: u32 = 99\n","export const GRAIN_NUMBER_TAG_TYPE: i32       = 0b0000;\nexport const GRAIN_CONST_TAG_TYPE: i32        = 0b1111;\nexport const GRAIN_TUPLE_TAG_TYPE: i32        = 0b0001;\nexport const GRAIN_LAMBDA_TAG_TYPE: i32       = 0b0101;\nexport const GRAIN_GENERIC_HEAP_TAG_TYPE: i32 = 0b0011;\n\nexport const GRAIN_NUMBER_TAG_MASK: i32 = 0b0001;\nexport const GRAIN_GENERIC_TAG_MASK: i32 = 0b0111;\n\nexport const GRAIN_STRING_HEAP_TAG: i32 = 1;\nexport const GRAIN_CHAR_HEAP_TAG: i32 = 2;\nexport const GRAIN_ADT_HEAP_TAG: i32 = 3;\nexport const GRAIN_RECORD_HEAP_TAG: i32 = 4;\nexport const GRAIN_ARRAY_HEAP_TAG: i32 = 5;\nexport const GRAIN_BOXED_NUM_HEAP_TAG: i32 = 6;\n\nexport const GRAIN_FILE_DESCRIPTOR_TYPE_ID: i32 = 9;\n\n// Boxed number types\nexport const GRAIN_FLOAT32_BOXED_NUM_TAG = 1;\nexport const GRAIN_FLOAT64_BOXED_NUM_TAG = 2;\nexport const GRAIN_INT32_BOXED_NUM_TAG = 3;\nexport const GRAIN_INT64_BOXED_NUM_TAG = 4;\nexport const GRAIN_RATIONAL_BOXED_NUM_TAG = 5;\n","export const GRAIN_TRUE: u32 = 0xFFFFFFFF\nexport const GRAIN_FALSE: u32 = 0x7FFFFFFF\nexport const GRAIN_VOID: u32 = 0x6FFFFFFF\n","import { throwError } from './ascutils/grainRuntime'\nimport { GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS, GRAIN_ERR_INVALID_ARGUMENT } from './ascutils/errors'\nimport { GRAIN_GENERIC_HEAP_TAG_TYPE } from './ascutils/tags'\nimport { stringSize, allocateString, allocateChar, allocateArray, storeInArray } from './ascutils/dataStructures'\nimport { GRAIN_TRUE, GRAIN_FALSE } from './ascutils/primitives'\n\nexport function length(s: u32): u32 {\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  const size = stringSize(s)\n\n  let len = 0\n  let ptr = s + 8\n  const end = ptr + size\n\n  while (ptr < end) {\n    const byte = load<u8>(ptr)\n    if ((byte & 0xC0) !== 0x80) len++\n    ptr++\n  }\n\n  return len << 1\n}\n\nexport function byteLength(s: u32): u32 {\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  const size = stringSize(s)\n\n  return size << 1\n}\n\nexport function indexOf(p: u32, s: u32): u32 {\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  p = p ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  const size = stringSize(s)\n  const psize = stringSize(p)\n\n  if (psize > size) return -1 << 1\n\n  let idx = 0\n  let ptr = s + 8\n  let pptr = p + 8\n  const end = ptr + size - psize + 1\n\n  while (ptr < end) {\n    if (memory.compare(ptr, pptr, psize) === 0) {\n      return idx << 1\n    }\n    idx++\n    const byte = load<u8>(ptr)\n    if ((byte & 0x80) === 0x00) {\n      ptr += 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      ptr += 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      ptr += 3\n    } else {\n      ptr += 2\n    }\n  }\n\n  return -1 << 1\n}\n\nfunction explodeHelp(str: u32, chars: bool): u32 {\n  let s = str ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  const size = stringSize(s)\n  const len = length(str) >> 1\n  \n  let ptr = s + 8\n  const end = ptr + size\n\n  let arr = allocateArray(len)\n  let arrIdx = 0\n\n  while (ptr < end) {\n    const byte = load<u8>(ptr)\n    let n: u32\n    if ((byte & 0x80) === 0x00) {\n      n = 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      n = 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      n = 3\n    } else {\n      n = 2\n    }\n\n    let c: u32\n    if (chars) {\n      c = allocateChar()\n      memory.copy(c + 4, ptr, n)\n    } else {\n      c = allocateString(n)\n      memory.copy(c + 8, ptr, n)\n    }\n    storeInArray(arr, arrIdx, c ^ GRAIN_GENERIC_HEAP_TAG_TYPE)\n    arrIdx++\n    ptr += n\n  }\n\n  return arr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function explode(str: u32): u32 {\n  return explodeHelp(str, true)\n}\n\nexport function implode(arr: u32): u32 {\n  arr = arr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  let arrLength = load<u32>(arr, 4)\n\n  let stringByteLength = 0\n\n  for (let i: u32 = 0; i < arrLength; i++) {\n    const char = load<u32>(arr + (i << 2), 8) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    const byte = load<u8>(char, 4)\n\n    let n: u32\n    if ((byte & 0x80) === 0x00) {\n      n = 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      n = 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      n = 3\n    } else {\n      n = 2\n    }\n\n    stringByteLength += n\n  }\n\n  let str = allocateString(stringByteLength)\n  let offset = 8\n\n  for (let i: u32 = 0; i < arrLength; i++) {\n    const char = load<u32>(arr + (i << 2), 8) ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n    const byte = load<u8>(char, 4)\n\n    let n: u32\n    if ((byte & 0x80) === 0x00) {\n      n = 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      n = 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      n = 3\n    } else {\n      n = 2\n    }\n\n    memory.copy(str + offset, char + 4, n)\n    offset += n\n  }\n\n  return str ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function split(pat: u32, str: u32): u32 {\n  let s = str ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  let p = pat ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  const size = stringSize(s)\n  const psize = stringSize(p)\n\n  if (psize === 0) {\n    return explodeHelp(str, false)\n  }\n  \n  if (psize > size) {\n    let ptr = allocateArray(1)\n    storeInArray(ptr, 0, str)\n    return ptr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  }\n\n  let ptr = s + 8\n  let pptr = p + 8\n  const end = ptr + size - psize + 1\n\n  let numStrings = 1\n\n  while (ptr < end) {\n    if (memory.compare(ptr, pptr, psize) === 0) {\n      numStrings++\n    }\n    const byte = load<u8>(ptr)\n    if ((byte & 0x80) === 0x00) {\n      ptr += 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      ptr += 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      ptr += 3\n    } else {\n      ptr += 2\n    }\n  }\n\n  ptr = s + 8\n  let last = ptr\n  let arr = allocateArray(numStrings)\n  let arrIdx = 0\n\n  while (ptr < end) {\n    if (memory.compare(ptr, pptr, psize) === 0) {\n      let strSize = ptr - last\n      let str = allocateString(strSize)\n      memory.copy(str + 8, last, strSize)\n      storeInArray(arr, arrIdx, str ^ GRAIN_GENERIC_HEAP_TAG_TYPE)\n      arrIdx++\n      ptr += psize\n      last = ptr\n      continue\n    }\n    const byte = load<u8>(ptr)\n    if ((byte & 0x80) === 0x00) {\n      ptr += 1\n    } else if ((byte & 0xF0) === 0xF0) {\n      ptr += 4\n    } else if ((byte & 0xE0) === 0xE0) {\n      ptr += 3\n    } else {\n      ptr += 2\n    }\n  }\n\n  // Grab last string\n  let strSize = s + 8 + size - last\n  let lastStr = allocateString(strSize)\n  memory.copy(lastStr + 8, last, strSize)\n  storeInArray(arr, arrIdx, lastStr ^ GRAIN_GENERIC_HEAP_TAG_TYPE)\n\n  return arr ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function slice(from: i32, to: i32, s: u32): u32 {\n  const len = i32(length(s) >> 1)\n\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  const size = stringSize(s)\n\n  from = from >> 1\n  to = to >> 1\n\n  if (from < 0) from += len\n  if (to < 0) to += len\n\n  if (from > len || to > len) {\n    throwError(GRAIN_ERR_ARRAY_INDEX_OUT_OF_BOUNDS, 0, 0)\n  }\n\n  if (to < from) {\n    throwError(GRAIN_ERR_INVALID_ARGUMENT, to << 1, 0)\n  }\n\n  let ptr = s + 8\n  let start = ptr\n  let end = ptr\n  const stop = ptr + size\n\n  let idx = 0\n  while (ptr < stop) {\n    const byte = load<u8>(ptr)\n    if ((byte & 0xC0) !== 0x80) {\n      if (idx === from) start = ptr\n      if (idx === to) {\n        end = ptr\n        break\n      }\n      idx++\n    }\n    ptr++\n  }\n  if (to === len) end = s + 8 + size\n  if (from === to) start = end\n\n  const newSize = end - start\n  const newString = allocateString(newSize)\n\n  memory.copy(newString + 8, start, newSize)\n\n  return newString ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function contains(p: u32, s: u32): u32 {\n  // \"Not So Naive\" string search algorithm\n  // searching phase in O(nm) time complexity\n  // slightly (by coefficient) sub-linear in the average case\n  // http://igm.univ-mlv.fr/~lecroq/string/node13.html#SECTION00130\n\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  p = p ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  const n = stringSize(s)\n  const m = stringSize(p)\n\n  s += 8\n  p += 8\n\n  let j: u32 = 0, k: u32, ell: u32\n\n  // Bail if pattern length is longer than input length\n  if (m > n) return GRAIN_FALSE\n\n  // Handle very small patterns\n  if (m < 2) {\n    if (m === 0) return GRAIN_TRUE\n    const pat = load<u8>(p)\n    while (j < n) if (pat === load<u8>(s + j)) {\n      return GRAIN_TRUE\n    } else j++\n    return GRAIN_FALSE\n  }\n\n  // NSM preprocessing\n  if (load<u8>(p) === load<u8>(p, 1)) {\n    k = 2\n    ell = 1\n  } else {\n    k = 1\n    ell = 2\n  }\n\n  // NSM searching\n  while (j <= n - m) {\n    if (load<u8>(p, 1) !== load<u8>(s + j, 1)) {\n      j += k\n    } else {\n      if (memory.compare(p + 2, s + j + 2, m - 2) === 0 &&\n        load<u8>(p) === load<u8>(s + j))\n        return GRAIN_TRUE\n      j += ell\n    }\n  }\n  return GRAIN_FALSE\n}\n\nexport function startsWith(p: u32, s: u32): u32 {\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  p = p ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  const n = stringSize(s)\n  const m = stringSize(p)\n\n  s += 8\n  p += 8\n\n  // Bail if pattern length is longer than input length\n  if (m > n) return GRAIN_FALSE\n\n  return memory.compare(p, s, m) === 0\n    ? GRAIN_TRUE\n    : GRAIN_FALSE\n}\n\nexport function endsWith(p: u32, s: u32): u32 {\n  s = s ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n  p = p ^ GRAIN_GENERIC_HEAP_TAG_TYPE\n\n  const n = stringSize(s)\n  const m = stringSize(p)\n\n  s += 8\n  p += 8\n\n  // Bail if pattern length is longer than input length\n  if (m > n) return GRAIN_FALSE\n\n  return memory.compare(p, s + n - m, m) === 0\n    ? GRAIN_TRUE\n    : GRAIN_FALSE\n}\n","import { malloc } from './grainRuntime'\n\nimport {\n  GRAIN_ARRAY_HEAP_TAG,\n  GRAIN_STRING_HEAP_TAG,\n  GRAIN_CHAR_HEAP_TAG,\n  GRAIN_BOXED_NUM_HEAP_TAG,\n  GRAIN_INT32_BOXED_NUM_TAG,\n  GRAIN_INT64_BOXED_NUM_TAG,\n  GRAIN_FLOAT32_BOXED_NUM_TAG,\n  GRAIN_FLOAT64_BOXED_NUM_TAG,\n  GRAIN_RATIONAL_BOXED_NUM_TAG,\n  GRAIN_GENERIC_HEAP_TAG_TYPE,\n} from './tags'\n\n/**\n * Allocates a new Grain array.\n *\n * @param {u32} numElts The number of elements to be contained in this array\n * @returns {u32} The (untagged) pointer to the array\n */\nexport function allocateArray(numElts: u32): u32 {\n  let arr = malloc((numElts + 2) * 4)\n\n  store<u32>(arr, GRAIN_ARRAY_HEAP_TAG)\n  store<u32>(arr, numElts, 4)\n\n  return arr\n}\n\n/**\n * Stores an item in a Grain array.\n *\n * @param {u32} array The (untagged) array to store the item in\n * @param {u32} idx The index to store the item\n * @param {u32} item The item to store\n */\n@inline\nexport function storeInArray(arr: u32, idx: u32, item: u32): void {\n  store<u32>(arr + idx * 4, item, 8)\n}\n\n/**\n * Allocates a new Grain tuple.\n *\n * @param {u32} numElts The number of elements to be contained in this tuple\n * @returns {u32} The (untagged) pointer to the tuple\n */\nexport function allocateTuple(numElts: u32): u32 {\n  let tuple = malloc((numElts + 1) * 4)\n\n  store<u32>(tuple, numElts)\n\n  return tuple\n}\n\n/**\n * Allocates a new Grain string.\n *\n * @param {u32} size The size (in bytes) of the string to allocate\n * @returns {u32} The (untagged) pointer to the string\n */\nexport function allocateString(size: u32): u32 {\n  let str = malloc(size + 8)\n\n  store<u32>(str, GRAIN_STRING_HEAP_TAG)\n  store<u32>(str, size, 4)\n\n  return str\n}\n\n/**\n * Allocates a new Grain char.\n *\n * @returns {u32} The (untagged) pointer to the char\n */\nexport function allocateChar(): u32 {\n  let char = malloc(8)\n\n  store<u32>(char, GRAIN_CHAR_HEAP_TAG)\n\n  return char\n}\n\nexport function singleByteString(char: u8): u32 {\n  let s = allocateString(1)\n  store<u8>(s, char, 8)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\nexport function twoByteString(char1: u8, char2: u8): u32 {\n  let s = allocateString(2)\n  store<u8>(s, char1, 8)\n  store<u8>(s, char2, 8 + 1)\n  return s | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n// [TODO] should probably migrate over the accessors in numbers.ts\n// INT32/INT64\n\n/**\n * Allocates a new Int64.\n *\n * @returns {u32}\n */\nexport function allocateInt64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int64 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt64(value: i64): u32 {\n  let ptr = allocateInt64()\n  store<i64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int64\n * @param wrappedInt64 The boxed int64 to return\n */\nexport function rawInt64Ptr(wrappedInt64: u32): u32 {\n  return wrappedInt64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64(xptr: u32): i64 {\n  return load<i64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt64Unsigned(xptr: u32): u64 {\n  return load<u64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Int32.\n *\n * @returns {u32}\n */\nexport function allocateInt32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_INT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Int32 with a prepopulated value\n * @param value The value to store\n */\nexport function newInt32(value: i32): u32 {\n  let ptr = allocateInt32()\n  store<i32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Int32\n * @param wrappedInt32 The boxed int32 to return\n */\nexport function rawInt32Ptr(wrappedInt32: u32): u32 {\n  return wrappedInt32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadInt32Unsigned(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// FLOATS\n\n/**\n * Allocates a new Float32.\n *\n * @returns {u32}\n */\nexport function allocateFloat32(): u32 {\n  let ptr = malloc(12)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT32_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float32 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat32(value: f32): u32 {\n  let ptr = allocateFloat32()\n  store<f32>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float32\n * @param wrappedFloat32 The boxed float32 to return\n */\nexport function rawFloat32Ptr(wrappedFloat32: u32): u32 {\n  return wrappedFloat32 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat32(xptr: u32): f32 {\n  return load<f32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n/**\n * Allocates a new Float64.\n *\n * @returns {u32}\n */\nexport function allocateFloat64(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_FLOAT64_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Float64 with a prepopulated value\n * @param value The value to store\n */\nexport function newFloat64(value: f64): u32 {\n  let ptr = allocateFloat64()\n  store<f64>(ptr + 8, value)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Float64\n * @param wrappedFloat64 The boxed float64 to return\n */\nexport function rawFloat64Ptr(wrappedFloat64: u32): u32 {\n  return wrappedFloat64 + 8\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadFloat64(xptr: u32): f64 {\n  return load<f64>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// RATIONALS\n\n/**\n * Allocates a new Rational.\n *\n * @returns {u32}\n */\nexport function allocateRational(): u32 {\n  let ptr = malloc(16)\n\n  store<u32>(ptr, GRAIN_BOXED_NUM_HEAP_TAG)\n  store<u32>(ptr + 4, GRAIN_RATIONAL_BOXED_NUM_TAG)\n\n  return ptr\n}\n\n/**\n * Allocates a new Rational with a prepopulated value\n * @param value The value to store\n */\nexport function newRational(numerator: i32, denominator: i32): u32 {\n  let ptr = allocateRational()\n  store<i32>(ptr + 8, numerator)\n  store<i32>(ptr + 12, denominator)\n  return ptr | GRAIN_GENERIC_HEAP_TAG_TYPE\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalNumeratorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 8\n}\n\n/**\n * Returns a pointer to the heap location containing this boxed number's Rational numerator\n * @param wrappedRational The boxed rational to return\n */\nexport function rawRationalDenominatorPtr(wrappedRational: u32): u32 {\n  return wrappedRational + 12\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalNumerator(xptr: u32): i32 {\n  return load<i32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 2 * 4)\n}\n\n// @ts-ignore: decorator\n@inline\nexport function loadRationalDenominator(xptr: u32): u32 {\n  return load<u32>(xptr & ~GRAIN_GENERIC_HEAP_TAG_TYPE, 3 * 4)\n}\n\n\n/**\n * Load a value from an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @param {u32} idx Index (from zero) of the item\n * @returns {u32} The value located at the index\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVal(ptr: u32, idx: u32): u32 {\n  return load<u32>(ptr + (idx * 4), 5 * 4)\n}\n\n/**\n * Load the (tagged) variant of an ADT.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the ADT\n * @returns {u32} The (tagged) ADT variant id\n */\n// @ts-ignore: decorator\n@inline\nexport function loadAdtVariant(ptr: u32): u32 {\n  return load<u32>(ptr, 3 * 4)\n}\n\n/**\n * Load an untagged string's size.\n *\n * @export\n * @param {u32} ptr Untagged pointer to the string\n * @returns {u32} The (untagged) string size (in bytes)\n */\n// @ts-ignore: decorator\n@inline\nexport function stringSize(ptr: u32): u32 {\n  return load<u32>(ptr, 4)\n}\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n - 4;\n    store<u8>(dest, c);\n    store<u8>(dend, c, 3);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend, c, 2);\n    store<u8>(dend, c, 1);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n - 28;\n    store<u32>(dest, c32);\n    store<u32>(dend, c32, 24);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend, c32, 16);\n    store<u32>(dend, c32, 20);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend, c32);\n    store<u32>(dend, c32, 4);\n    store<u32>(dend, c32, 8);\n    store<u32>(dend, c32, 12);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n"]}